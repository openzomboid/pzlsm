#!/bin/bash

# Project Zomboid Linux Server Manager.
#
# Copyright (c) 2023 Pavel Korotkiy (outdead).
# Use of this source code is governed by the MIT license.
#
# DO NOT EDIT THIS FILE!
#
# To change config go to config/pzlsm.cfg file.
# This file will never be updated automatically.

# VERSION of Project Zomboid Linux Server Manager.
# Follows semantic versioning, SEE: http://semver.org/.
VERSION="0.22.35"
YEAR="2023"
AUTHOR="Pavel Korotkiy (outdead)"

# Color variables. Used when displaying messages in stdout.
GREEN='\033[0;32m'; RED='\033[0;31m'; YELLOW='\033[0;33m'; BLUE='\033[0;36m'; NC='\033[0m'

# Message types. Used when displaying messages in stdout.
OK=$(echo -e "[ ${GREEN} OK ${NC} ]"); ER=$(echo -e "[ ${RED} ER ${NC} ]"); WARN=$(echo -e "[ ${YELLOW} YELLOW ${NC} ]"); INFO=$(echo -e "[ ${BLUE}INFO${NC} ]")

# Project Zomboid App ID and Dedicated Server App ID in Steam.
APP_ID=108600
APP_DEDICATED_ID=380870

BASEDIR=$(dirname "$(readlink -f "${BASH_SOURCE[@]}")")
SCRIPT_LOCATION=${BASEDIR}

# MEMORY_AVAILABLE is the amount of memory available on the server in MB.
MEMORY_AVAILABLE=$(free | awk 'NR==2 { printf("%.0f", $2/1024); }')

# MEMORY_USED is the amount of memory used on the server in MM.
MEMORY_USED=$(free | awk 'NR==2 { printf("%.0f", $3/1024); }')

# CPU_CORE_COUNT is the number of processors cores on the server.
CPU_CORE_COUNT=$(nproc)

# NOW is the current date and time in default format Y%m%d_%H%M%S.
# You can change format in config file.
NOW=$(date "+%Y%m%d_%H%M%S")

# TIMESTAMP is current timestamp.
TIMESTAMP=$(date "+%s")

ENV_FILE="${BASEDIR}/.env"

# Import env file if exists.
# shellcheck source=.env
test -f "${ENV_FILE}" && . "${ENV_FILE}"

# Linux Server Manager directories definitions.
DIR_BACKUPS="${BASEDIR}/backups"
DIR_UTILS="${BASEDIR}/utils"
DIR_PZLSD="${BASEDIR}/utils/pzlsd"
DIR_PLUGINS="${BASEDIR}/utils/plugins"
DIR_LOGS="${BASEDIR}/logs"
DIR_CONFIG="${BASEDIR}/config"
DIR_PUBLIC="${BASEDIR}/public"
DIR_STATE="${BASEDIR}/state"

DIR_BACKUPS_DOWN="${DIR_BACKUPS}/down"
DIR_BACKUPS_ZOMBOID="${DIR_BACKUPS}/zomboid"
DIR_BACKUPS_PZLSD="${DIR_BACKUPS}/pzlsd"
DIR_BACKUPS_COPY="${DIR_BACKUPS}/copy"
DIR_BACKUPS_PLAYERS="${DIR_BACKUPS}/players"
DIR_BACKUPS_TIME_MACHINE="${DIR_BACKUPS}/timemachine"

# Linux Server Manager files definitions.
FILE_PZLSM_LOG="${DIR_LOGS}/pzlsm.log"
FILE_PZLSM_CONFIG="${DIR_CONFIG}/pzlsm.cfg"
FILE_PZLSM_STATE="${DIR_STATE}/pzlsm.json"

# Import config file if exists.
# shellcheck source=config/pzlsm.cfg
test -f "${FILE_PZLSM_CONFIG}" && . "${FILE_PZLSM_CONFIG}"

BASENAME=$(basename "${BASEDIR}")

## Check config variables and set default values if not defined.
[ -z "${CLEAR_MAP_DAY}" ] && CLEAR_MAP_DAY=0
[ -z "${CLEAR_LOGS_DAY}" ] && CLEAR_LOGS_DAY=0
[ -z "${CLEAR_STACK_TRACE_DAY}" ] && CLEAR_STACK_TRACE_DAY=0
[ -z "${CLEAR_BACKUPS_DAY}" ] && CLEAR_BACKUPS_DAY=7
[ -z "${CLEAR_TIME_MACHINE_DAY}" ] && CLEAR_TIME_MACHINE_DAY=5
[ -z "${UTIL_RANGE_VERSION}" ] && UTIL_RANGE_VERSION="1.0.1"
[ -z "${UTIL_RCON_VERSION}" ] && UTIL_RCON_VERSION="0.10.2"
[ -z "${SERVER_MEMORY_LIMIT}" ] && SERVER_MEMORY_LIMIT=2048
[ -z "${SERVER_NAME}" ] && SERVER_NAME="servertest"
[ -z "${ZOMBOID_HOME_DIR}" ] && ZOMBOID_HOME_DIR=".\/"
[ -z "${SCREEN_ZOMBOID}" ] && SCREEN_ZOMBOID="${SERVER_NAME}"
[ -z "${SERVER_LANG}" ] && SERVER_LANG="en"
[ -z "${SERVER_DIR}" ] && SERVER_DIR="${BASEDIR}/projectzomboid"
[ -z "${ZOMBOID_DIR}" ] && ZOMBOID_DIR="${BASEDIR}/Zomboid"
[ -z "${FIRST_RUN_ADMIN_PASSWORD}" ] && FIRST_RUN_ADMIN_PASSWORD="changeme"
[ -z "${BACKUP_ON_STOP}" ] && BACKUP_ON_STOP="false"
[ -z "${AUTO_RESTORE}" ] && AUTO_RESTORE="false"

[ -z "${STEAMCMD_USERNAME}" ] && STEAMCMD_USERNAME="anonymous"
[ -z "${STEAMCMD_BETA}" ] && STEAMCMD_BETA="-beta none"

[ -z "${PZLSM_SOURCE_LINK}" ] && PZLSM_SOURCE_LINK="https://raw.githubusercontent.com/openzomboid/pzlsm/master"

[ -z "${WRITE_PZLSM_LOGS}" ] && WRITE_PZLSM_LOGS="false"

## Utils

# Numeric range regular expression builder written in bash.
# https://github.com/outdead/regex-range-builder.
UTIL_RANGE_LINK="https://github.com/outdead/regex-range-builder/archive/v${UTIL_RANGE_VERSION}.tar.gz"
UTIL_RANGE_DIR="${DIR_UTILS}/regex-range-builder-${UTIL_RANGE_VERSION}"
UTIL_RANGE_FILE="${UTIL_RANGE_DIR}/range.sh"

# Rcon client for executing queries on game server.
# https://github.com/gorcon/rcon-cli.
UTIL_RCON_LINK="https://github.com/gorcon/rcon-cli/releases/download/v${UTIL_RCON_VERSION}/rcon-${UTIL_RCON_VERSION}-amd64_linux.tar.gz"
UTIL_RCON_DIR="${DIR_UTILS}/rcon-${UTIL_RCON_VERSION}-amd64_linux"
UTIL_RCON_FILE="${UTIL_RCON_DIR}/rcon"

## Directories in Zomboid folder.

ZOMBOID_DIR_SAVES="${ZOMBOID_DIR}/Saves"
ZOMBOID_DIR_LOGS="${ZOMBOID_DIR}/Logs"
ZOMBOID_DIR_SERVER="${ZOMBOID_DIR}/Server"
ZOMBOID_DIR_DB="${ZOMBOID_DIR}/db"
ZOMBOID_DIR_MAP="${ZOMBOID_DIR_SAVES}/Multiplayer/${SERVER_NAME}"

ZOMBOID_FILE_CONFIG_INI="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}.ini"
ZOMBOID_FILE_CONFIG_SANDBOX="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}_SandboxVars.lua"
ZOMBOID_FILE_CONFIG_SPAWNPOINTS="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}_spawnpoints.lua"
ZOMBOID_FILE_CONFIG_SPAWNREGIONS="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}_spawnregions.lua"
ZOMBOID_FILE_DB="${ZOMBOID_DIR_DB}/${SERVER_NAME}.db"
ZOMBOID_FILE_VEHICLES_DB="${ZOMBOID_DIR_MAP}/vehicles.db"
ZOMBOID_FILE_PLAYERS_DB="${ZOMBOID_DIR_MAP}/players.db"

ZOMBOID_MANIFEST="${SERVER_DIR}/steamapps/appmanifest_${APP_DEDICATED_ID}.acf"
ZOMBOID_MODS_MANIFEST="${SERVER_DIR}/steamapps/workshop/appworkshop_${APP_ID}.acf"

if [ -f "${ZOMBOID_DIR}/server-console.txt" ]; then
  PZ_VERSION=$(grep -roE "versionNumber=[0-9]+.[0-9]+" "${ZOMBOID_DIR}/server-console.txt" | grep -Eo "[0-9]+.[0-9]+")
fi
[ -z "${PZ_VERSION}" ] && PZ_VERSION="$(echo -e "${RED}undefined${NC}")"

fn_exists() { declare -F "$1" > /dev/null; }

# echoerr prints red error message to stderr and FILE_PZLSM_LOG file.
function echoerr() {
  echo "${ER} $1"
  if [ "${WRITE_PZLSM_LOGS}" == "true" ]; then
    mkdir -p "${DIR_LOGS}"
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] $0 - $1" >> "${FILE_PZLSM_LOG}"
  fi
}

# echowarn prints yellow error message to stderr and FILE_PZLSM_LOG file.
function echowarn() {
  echo "${WARN} $1"
  if [ "${WRITE_PZLSM_LOGS}" == "true" ]; then
    mkdir -p "${DIR_LOGS}"
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] $0 - $1" >> "${FILE_PZLSM_LOG}"
  fi
}

# get_screen_pid prints server's pid.
function get_screen_pid() {
  ps aux | grep -v grep | grep -i "screen -U -mdS ${SCREEN_ZOMBOID} " | awk '{print $2}'
}

# get_server_pid prints server's pid.
function get_server_pid() {
  pgrep -af ProjectZomboid64 | grep "servername ${SERVER_NAME}" | grep -o -e "^[0-9]*"
}

# is_server_running prints true if server is running, or false if is not.
function is_server_running() {
  [ -n "$(get_screen_pid)" ] && echo "true" || echo "false"
}

# is_admin_exists prints true if admin username exists in PZ database.
function is_admin_exists() {
  [ "$(sqlite3 "${ZOMBOID_FILE_DB}" "SELECT count(*) FROM whitelist WHERE username='admin'" 2> /dev/null)" == "1" ] && echo "true" || echo "false"
}

# print_variables prints pzlsm variables.
# TODO: Add all variables.
function print_variables() {
  check_dir() {
    [ ! -d "$1" ] && echo -e "${RED} (not exists)${NC}"
  }

  check_file() {
    [ ! -f "$1" ] && echo -e "${RED} (not exists)${NC}"
  }

  echo "${INFO} MEMORY_AVAILABLE:            ${MEMORY_AVAILABLE}"
  echo "${INFO} MEMORY_USED:                 ${MEMORY_USED}"
  echo "${INFO} CPU_CORE_COUNT:              ${CPU_CORE_COUNT}"
  echo "${INFO} APP_ID:                      ${APP_ID}"
  echo "${INFO} APP_DEDICATED_ID:            ${APP_DEDICATED_ID}"
  echo "${INFO} SCREEN_ZOMBOID:              ${SCREEN_ZOMBOID}"
  echo "${INFO} NOW:                         ${NOW}"
  echo "${INFO} TIMESTAMP:                   ${TIMESTAMP}"
  echo "${INFO} BASEDIR:                     ${BASEDIR}"
  echo "${INFO}"
  echo "${INFO} FILE_PZLSM_LOG:              ${FILE_PZLSM_LOG}$(check_file "${FILE_PZLSM_LOG}")"
  echo "${INFO} FILE_PZLSM_CONFIG:           ${FILE_PZLSM_CONFIG}$(check_file "${FILE_PZLSM_CONFIG}")"
  echo "${INFO} UTIL_RANGE_FILE:             ${UTIL_RANGE_FILE}$(check_file "${UTIL_RANGE_FILE}")"
  echo "${INFO} UTIL_RCON_FILE:              ${UTIL_RCON_FILE}$(check_file "${UTIL_RCON_FILE}")"
  echo "${INFO}"
  echo "${INFO} SERVER_DIR:                  ${SERVER_DIR}$(check_dir "${SERVER_DIR}")"
  echo "${INFO} ZOMBOID_DIR:                 ${ZOMBOID_DIR}$(check_dir "${ZOMBOID_DIR}")"
  echo "${INFO} ZOMBOID_DIR_SAVES:           ${ZOMBOID_DIR_SAVES}$(check_dir "${ZOMBOID_DIR_SAVES}")"
  echo "${INFO} ZOMBOID_DIR_LOGS:            ${ZOMBOID_DIR_LOGS}$(check_dir "${ZOMBOID_DIR_LOGS}")"
  echo "${INFO} ZOMBOID_DIR_SERVER:          ${ZOMBOID_DIR_SERVER}$(check_dir "${ZOMBOID_DIR_SERVER}")"
  echo "${INFO} ZOMBOID_DIR_DB:              ${ZOMBOID_DIR_DB}$(check_dir "${ZOMBOID_DIR_DB}")"
  echo "${INFO} ZOMBOID_DIR_MAP:             ${ZOMBOID_DIR_MAP}$(check_dir "${ZOMBOID_DIR_MAP}")"
  echo "${INFO}"
  echo "${INFO} ZOMBOID_FILE_CONFIG_INI:     ${ZOMBOID_FILE_CONFIG_INI}$(check_file "${ZOMBOID_FILE_CONFIG_INI}")"
  echo "${INFO} ZOMBOID_FILE_CONFIG_SANDBOX: ${ZOMBOID_FILE_CONFIG_SANDBOX}$(check_file "${ZOMBOID_FILE_CONFIG_SANDBOX}")"
  echo "${INFO} ZOMBOID_FILE_DB:             ${ZOMBOID_FILE_DB}$(check_file "${ZOMBOID_FILE_DB}")"
  echo "${INFO}"
  echo "${INFO} DIR_PLUGINS:                 ${DIR_PLUGINS}"
}

# save_config_example saves pzlsm config example.
function save_config_example() {
  bash -c "cat <<'EOF' > ${DIR_CONFIG}/pzlsm.example.cfg
#!/usr/bin/env bash

# SERVER_MEMORY_LIMIT contains memory Limit for JVM in MB.
SERVER_MEMORY_LIMIT=${SERVER_MEMORY_LIMIT}

# SERVER_NAME contains name of Project Zomboid server.
SERVER_NAME=\"${SERVER_NAME}\"

# CLEAR_MAP_DAY contains the number of days after which map chunks will
# be deleted if no one has visited them. Set to 0 to turn off.
CLEAR_MAP_DAY=${CLEAR_MAP_DAY}

# CLEAR_LOGS_DAY contains the number of days after which old game logs will
# be deleted. Set to 0 to turn off.
CLEAR_LOGS_DAY=${CLEAR_LOGS_DAY}

# CLEAR_STACK_TRACE_DAY contains the number of days after which old game
# hs_err_pid (java stack traces) files will be deleted. Set to 0 to turn off.
CLEAR_STACK_TRACE_DAY=${CLEAR_STACK_TRACE_DAY}

# CLEAR_BACKUPS_DAY contains the number of days after which old backups
# will be deleted. Set to 0 to turn off.
CLEAR_BACKUPS_DAY=${CLEAR_BACKUPS_DAY}

# CLEAR_TIME_MACHINE_DAY contains the number of days after which old
# time machine backups will be deleted. Set to 0 to turn off.
CLEAR_TIME_MACHINE_DAY=${CLEAR_TIME_MACHINE_DAY}

# BACKUP_ON_STOP contains switcher to make backup on every server stop.
BACKUP_ON_STOP=\"${BACKUP_ON_STOP}\"

# FIRST_RUN_ADMIN_PASSWORD contains password for user admin which be created
# on first server run.
FIRST_RUN_ADMIN_PASSWORD=\"${FIRST_RUN_ADMIN_PASSWORD}\"

# AUTO_RESTORE contains switcher to restart server if it was down.
AUTO_RESTORE=\"${AUTO_RESTORE}\"

# GITHUB_CONFIG_REPO contains link to github repo with pz config files.
# Leave it blank if you don't plan to use this.
GITHUB_CONFIG_REPO=\"${GITHUB_CONFIG_REPO}\"

# GITHUB_ACCESS_TOKEN contains access token for download server configs from GitHub.
# Leave it blank if you don't plan to use this.
GITHUB_ACCESS_TOKEN=\"${GITHUB_ACCESS_TOKEN}\"

# WRITE_PZLSM_LOGS turns on pzlsm logging.
WRITE_PZLSM_LOGS=\"${WRITE_PZLSM_LOGS}\"

DIR_PLUGINS=\"${DIR_PLUGINS}\"
EOF"
}

# print_version prints versions.
# TODO: Check installations.
function print_version() {
  echo "${INFO} Project Zomboid build ${PZ_VERSION}"
  echo "${INFO} pzlsm version ${VERSION}"
  echo "${INFO} gorcon version ${UTIL_RCON_VERSION}"
  echo "${INFO} range version ${UTIL_RANGE_VERSION}"
}

# strclear removes all spaces, quotation marks and tabs from a string.
function strclear() {
  local str=${1//\"/}; str=${str// /}; str=${str//$'\t'/}
  echo "${str}"
}

# install_dependencies installs the necessary dependencies to the server.
# You must have sudo privileges to call function install_dependencies.
# This is the only function in this script that needs root privileges.
# You can install dependencies yourself before running this script and do
# not call this function.
function install_dependencies() {
  sudo apt-get update

  # If a 64-bit version of the system is used, then 32-bit libraries must
  # be installed for SteamCMD.
  if [ "$(arch)" == "x86_64" ]; then
    sudo apt-get install -y lib32gcc-s1
  fi

  # Update the C libraries for system calls.
  sudo apt-get install -y libc6 libc6-dev libc6-dbg linux-libc-dev gcc

  # Install Java-SDK. It is required to run the Project Zomboid game server.
  sudo apt-get install -y openjdk-17-jdk

  # Install screen to run Project Zomboid in the background.
  sudo apt-get install -y screen

  # To access the game database, you will need the sqlite3 library.
  sudo apt-get install -y sqlite3

  # Install basic calculator.
  sudo apt-get install -y bc

  # Install jq for json config parsing.
  sudo apt-get install -y jq

  sudo apt-get install -y net-tools nmap

  echo "${OK} dependencies installed"
}

# create_folders creates folders for pzlsm script.
function create_folders() {
  mkdir -p "${DIR_BACKUPS}"
  mkdir -p "${DIR_LOGS}"
  mkdir -p "${DIR_CONFIG}"
  mkdir -p "${DIR_PUBLIC}"
  mkdir -p "${DIR_UTILS}"
  mkdir -p "${DIR_PZLSD}"
  mkdir -p "${DIR_PLUGINS}" # TODO: Spit into two variables.
  mkdir -p "${DIR_STATE}"

  # Config.
  save_config_example

  # Backups.
  mkdir -p "${DIR_BACKUPS_DOWN}"
  mkdir -p "${DIR_BACKUPS_ZOMBOID}"
  mkdir -p "${DIR_BACKUPS_PZLSD}"
  mkdir -p "${DIR_BACKUPS_COPY}"
  mkdir -p "${DIR_BACKUPS_PLAYERS}"
  mkdir -p "${DIR_BACKUPS_TIME_MACHINE}"

  # Logs
  mkdir -p "${DIR_LOGS}/gc"

  # Public.
  mkdir -p "${DIR_PUBLIC}/saves"
  mkdir -p "${DIR_PUBLIC}/logs"

  rm -f "${DIR_PUBLIC}/backups"
  rm -f "${DIR_PUBLIC}/logs/server"
  rm -f "${DIR_PUBLIC}/logs/gc"

  ln -s "${DIR_BACKUPS}" "${DIR_PUBLIC}/backups"
  ln -s "${ZOMBOID_DIR_LOGS}" "${DIR_PUBLIC}/logs/server"
  ln -s "${DIR_LOGS}/gc" "${DIR_PUBLIC}/logs/gc"

  ln -sf "${ZOMBOID_DIR_MAP}/WorldDictionary.bin" "${DIR_PUBLIC}/saves/WorldDictionary.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/WorldDictionaryLog.lua" "${DIR_PUBLIC}/saves/WorldDictionaryLog.lua"
  ln -sf "${ZOMBOID_DIR_MAP}/WorldDictionaryReadable.lua" "${DIR_PUBLIC}/saves/WorldDictionaryReadable.lua"
  ln -sf "${ZOMBOID_DIR_MAP}/erosion.ini" "${DIR_PUBLIC}/saves/erosion.ini"
  ln -sf "${ZOMBOID_DIR_MAP}/global_mod_data.bin" "${DIR_PUBLIC}/saves/global_mod_data.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_campfire.bin" "${DIR_PUBLIC}/saves/gos_campfire.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_farming.bin" "${DIR_PUBLIC}/saves/gos_farming.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_metaldrum.bin" "${DIR_PUBLIC}/saves/gos_metaldrum.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_rainbarrel.bin" "${DIR_PUBLIC}/saves/gos_rainbarrel.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_trap.bin" "${DIR_PUBLIC}/saves/gos_trap.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/map_meta.bin" "${DIR_PUBLIC}/saves/map_meta.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/map_t.bin" "${DIR_PUBLIC}/saves/map_t.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/map_zone.bin" "${DIR_PUBLIC}/saves/map_zone.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/players.db" "${DIR_PUBLIC}/saves/players.db"
  ln -sf "${ZOMBOID_DIR_MAP}/reanimated.bin" "${DIR_PUBLIC}/saves/reanimated.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/recorded_media.bin" "${DIR_PUBLIC}/saves/recorded_media.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/vehicles.db" "${DIR_PUBLIC}/saves/vehicles.db"
  ln -sf "${ZOMBOID_DIR_MAP}/z_outfits.bin" "${DIR_PUBLIC}/saves/z_outfits.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/zpop_virtual.bin" "${DIR_PUBLIC}/saves/zpop_virtual.bin"

  ln -sf "${ZOMBOID_FILE_DB}" "${DIR_PUBLIC}/saves/${SERVER_NAME}.db"

  echo "${OK} folders created"
}

# install_range_builder downloads the regex-range-builder script and puts it
# in the utils directory.
function install_range_builder() {
  test -d "${UTIL_RANGE_DIR}" && echo "${UTIL_RANGE_DIR}" && return

  wget -P "${DIR_UTILS}" "${UTIL_RANGE_LINK}"
  tar -zxvf "${DIR_UTILS}/v${UTIL_RANGE_VERSION}.tar.gz" -C "${DIR_UTILS}"
  rm "${DIR_UTILS}/v${UTIL_RANGE_VERSION}.tar.gz"
}

# install_rcon downloads the rcon client and puts it in the utils directory.
function install_rcon() {
  test -d "${UTIL_RCON_DIR}" && echo "${UTIL_RCON_DIR}" && return

  wget -P "${DIR_UTILS}" "${UTIL_RCON_LINK}"
  tar -zxvf "${DIR_UTILS}/rcon-${UTIL_RCON_VERSION}-amd64_linux.tar.gz" -C "${DIR_UTILS}"
  rm "${DIR_UTILS}/rcon-${UTIL_RCON_VERSION}-amd64_linux.tar.gz"
}

# install_server installs Project Zomboid dedicated server.
# As arguments, you can pass validate and beta parameters in any order.
# If validate, the integrity and relevance of the current files will be checked.
# The beta parameter will download and install the game from the experimental
# IWBUMS branch. Only the latest stable and IWBUMS branches are supported.
function install_server() {
  if [ "$(is_server_running)" == "true" ]; then
    echo "${ER} cannot install on started server"; return 0
  fi

  local beta="${STEAMCMD_BETA}"

  case $1 in
    none)
      beta="-beta none";;
    unstable)
      beta="-beta unstable";;
    iwbums)
      beta="-beta iwillbackupmysave -betapassword iaccepttheconsequences";;
    *)
      if [ -n "$1" ]; then
        beta="-beta $1"
      fi
  esac

  # Create a directory for steamcmd and go to it. If the directory
  # already exists, no errors occur.
  mkdir -p "${HOME}/steamcmd" && cd "${HOME}/steamcmd" || return

  # Download steamcmd if it is not in the specified directory.
  if [ ! -f "steamcmd.sh" ]; then
    wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz && tar -xvzf steamcmd_linux.tar.gz
    rm steamcmd_linux.tar.gz
  fi

  # Install Project Zomboid Server.
  ./steamcmd.sh +login "${STEAMCMD_USERNAME}" +force_install_dir "${SERVER_DIR}" +app_update ${APP_DEDICATED_ID} ${beta} validate +exit

  # Return to the script directory.
  cd "${BASEDIR}" || return

  echo "${OK} server installed"
}

# update_server updates Project Zomboid dedicated server.
function update_server() {
  if [ "$(is_server_running)" == "true" ]; then
    echo "${ER} cannot update on started server"; return 0
  fi

  cd "${HOME}/steamcmd" || return

  # Update Project Zomboid Server.
  ./steamcmd.sh +login "${STEAMCMD_USERNAME}" +force_install_dir "${SERVER_DIR}" +app_update ${APP_DEDICATED_ID} validate +exit

  # Return to the script directory.
  cd "${BASEDIR}" || return

  echo "${OK} server updated"
}

# fix_options changes game language to EN.
function fix_options() {
  sed -i -r "s/language=.*/language=EN/g" "${ZOMBOID_DIR}/options.ini"

  echo "${OK} options fixed"
}

# fix_args sets the home directory for the game, utf8 encoding, server name,
# game language, changes GC option.
function fix_args() {
  local arg_home=""
  arg_home=$(grep "Duser.home" "${SERVER_DIR}/ProjectZomboid64.json")
  [ "${arg_home}" ] && return 0

  # Set memory limit for JVM.
  sed -i -r "s/Xmx8g/Xmx${SERVER_MEMORY_LIMIT}m/g" "${SERVER_DIR}/ProjectZomboid64.json"

  # Change GC type.
  sed -i -r "s/UseZGC/UseG1GC/g" "${SERVER_DIR}/ProjectZomboid64.json"

  local set_home="\"-Duser.home=${ZOMBOID_HOME_DIR}\""
  local set_encoding='"-Dfile.encoding=UTF-8"'
  local set_servername="\"-Dservername=${SERVER_NAME}\""
  local set_serverlang="\"-Duser.language=${SERVER_LANG}\""
  local set_gclog="\"-Xlog:gc*,gc+heap=debug,age*=debug:file=${DIR_LOGS}/gc/gc.out:time,uptime,level,tags:filesize=0:filecount=0\""

  local indent="\r\n\t\t"
  local _search='"-Dzomboid.steam=1",'
  local _replace="${_search}${indent}${set_home},${indent}${set_encoding},${indent}${set_servername},${indent}${set_serverlang},${indent}${set_gclog},"

  sed -i -r "s|${_search}|${_replace}|g" "${SERVER_DIR}/ProjectZomboid64.json"

  echo "${OK} args fixed"
}

# start starts the server in a screen window.
# An error message will be displayed if server has been started earlier.
function start() {
  echo "${INFO} starting the server..."

  local no_screen="$1"

  if [ "$(is_server_running)" == "true" ]; then
    echo "${INFO} server already started"; return 0
  fi

  rm -f "${DIR_STATE}/started"

  screen -wipe > /dev/null 2>&1; sleep 1s

  if [ "$no_screen" == "true" ]; then
    if ! "${SERVER_DIR}/start-server.sh" -servername "${SERVER_NAME}"; then
      echoerr "server is not started"; return 1
    fi
  else
    if ! env LANG=ru_RU.utf8 screen -U -mdS "${SCREEN_ZOMBOID}" "${SERVER_DIR}/start-server.sh" -servername "${SERVER_NAME}"; then
      echoerr "server is not started"; return 1
    fi
  fi

  if [ "$(is_admin_exists)" == "false" ] && [ -n "${FIRST_RUN_ADMIN_PASSWORD}" ]; then
    sleep 1s && screencmd "${FIRST_RUN_ADMIN_PASSWORD}"
    sleep 1s && screencmd "${FIRST_RUN_ADMIN_PASSWORD}"
  fi

  mkdir -p "${DIR_STATE}" && echo "${NOW}" > "${DIR_STATE}/started"
}

# stop stops the server.
function stop() {
  echo "${INFO} stopping the server..."

  rm -f "${DIR_STATE}/started"

  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server already stopped"; return 0
  fi

  # kickusers is used for fix a game bug.
  # When `quit` game command is executed, there is no log record the fact
  # that the players was exit the game. If you make a forced kick from the
  # server, then the log entry appears correctly.
  kickusers

  sleep 1s

  if ! screencmd 'quit'; then
    echoerr "server is not stopped correctly"
  fi

  # If after a regular shutdown server remains running, we must forcibly stop it.
  sleep 20s

  local pid_screen
  pid_screen=$(get_screen_pid)
  if [ -n "${pid_screen}" ]; then
    echo "${INFO} kill screen process ${pid_screen}"
    kill "${pid_screen}" > /dev/null 2>&1; sleep 1s
  fi

  echo "${OK} server is stopped"

  if [ "$1" == "fix" ] || [ "$2" == "fix" ]; then
    delete_mods_manifest
  fi

  if [ "${NO_TASKS_ON_STOP}" == "true" ]; then
    echo "${INFO} no tasks enabled"; return 0
  fi

  if [ "$1" == "now" ] || [ "$1" == "kill" ]; then
    return 0
  fi

  # After a stopping the server invokes the function of cleaning garbage that
  # the game generates during its operation.
  delete_old_chunks "${CLEAR_MAP_DAY}"
  delete_old_logs "${CLEAR_LOGS_DAY}"
  delete_old_java_stack_traces "${CLEAR_STACK_TRACE_DAY}"

  # Backups.
  if [ "${BACKUP_ON_STOP}" == "true" ]; then
      backup "world"
      backup "pzlsd"
  fi
}

# restart stops the server and starts it after 10 seconds.
function restart() {
  echo "${INFO} restarting the server..."

  stop "$1" "$2"
  sleep 10s
  start
}

# autorestart restarts server if it stuck.
function autorestart() {
  if [ "${AUTO_RESTORE}" != "true" ]; then
    return 0
  fi

  local pid_zomboid=""
  pid_zomboid=$(get_server_pid)
  if [ -z "${pid_zomboid}" ] && [ -f "${DIR_STATE}/started" ]; then
    NOW=$(date "+%Y%m%d_%H%M%S")

    local down="${DIR_BACKUPS_DOWN}/${NOW}"
    mkdir "${down}"

    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -name \*.txt -exec cp {} "${down}" \;
    cp "${ZOMBOID_DIR}/server-console.txt" "${down}"
    cp "${DIR_LOGS}/gc/gc.out" "${down}"

    start

    return 0
  fi

  local result
  result=$(rconcmd players 5s 2>&1 >/dev/null | grep ': i/o timeout')
  if [ -n "${result}" ]; then
    NOW=$(date "+%Y%m%d_%H%M%S")

    local down="${DIR_BACKUPS_DOWN}/${NOW}"
    mkdir "${down}"

    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -name \*.txt -exec cp {} "${down}" \;
    cp "${ZOMBOID_DIR}/server-console.txt" "${down}"
    cp "${DIR_LOGS}/gc/gc.out" "${down}"

    restart kill
  fi
}

# stats displays information on the peak processor consumption and
# current RAM consumption.
function stats() {
  local pid_zomboid=""
  pid_zomboid=$(get_server_pid)
  if [ -z "${pid_zomboid}" ]; then
    echoerr "server is not running"; return 1
  fi

  local cpu; cpu=$(strclear "$(ps S -p "${pid_zomboid}" -o pcpu=)")

  local mem1; mem1=$(ps S -p "${pid_zomboid}" -o pmem=)
  local mem2; mem2=$(ps -ylp "${pid_zomboid}" | awk '{x += $8} END {print "" x/1024;}')

  local jvmres; jvmres=$(jstat -gc "${pid_zomboid}")

  local jvm1; jvm1=$(echo "${jvmres}" | awk 'NR>1 { printf("%.1f", $8/$7*100); }')
  local jvm2; jvm2=$(echo "${jvmres}" | awk 'NR>1 { printf("%.2f", $8/1024); }')
  local jvm3; jvm3=$(echo "${jvmres}" | awk 'NR>1 { printf("%.2f", $7/1024); }')

  local mem_used_percent=$((100*"${MEMORY_USED}"/"${MEMORY_AVAILABLE}"))

  local uptime; uptime=$(ps -p "${pid_zomboid}" -o etime | grep -v "ELAPSED" | xargs)

  echo "${INFO} cpu srv:  ${cpu}%"
  echo "${INFO} mem host: ${mem_used_percent}% (${MEMORY_USED} MB from ${MEMORY_AVAILABLE})"
  echo "${INFO} mem srv:  ${mem1}% (${mem2} MB)"
  echo "${INFO} mem jvm:  ${jvm1}% (${jvm2} MB from ${jvm3} MB)"
  echo "${INFO} uptime:   ${uptime}"
}

# stats_top prints list of top $1 processes with memory usage.
function stats_top() {
  local number="$1"
  [ -z "${number}" ] && number=10

  ps axo rss,comm,pid | awk '{ proc_list[$2]++; proc_list[$2 "," 1] += $1; } END { for (proc in proc_list) { printf("%d\t%s\n", proc_list[proc "," 1],proc); }}' | sort -n | tail -n ${number} | sort -rn | awk '{$1/=1024;printf "%.0fMB\t",$1}{print $2}'
}

# shutdown_wrapper triggers informational messages for players to alert them of
# impending server shutdown. After 5 minutes, it calls the stop or restart
# function.
function shutdown_wrapper() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server already stopped"
    return 0
  fi

  ticker() {
    local msg=$1

    if [ "$2" != "now" ] && [ "$2" != "kill" ]; then
      echo "${INFO} ${msg} 5 minutes"
      screencmd "servermsg \"${msg} 5 minutes\""

      sleep 240s

      echo "${INFO} ${msg} 1 minute";
      screencmd "servermsg \"${msg} 1 minute\""

      sleep 50s
    fi

    if [ "$2" != "kill" ]; then
      echo "${INFO} ${msg} 10 seconds";
      screencmd "servermsg \"${msg} 10 seconds\""

      sleep 5s
      t=5
      while [ ${t} -gt 0 ]; do
        screencmd "servermsg \"${msg} ${t} seconds\""
        sleep 1s
        ((t=t-1))
      done
    fi
  }

  case "$1" in
    stop)
      ticker "Stopping the server in" "$2"
      stop "$2" "$3"
      ;;
    restart)
      ticker "Restarting the server in" "$2"
      restart "$2" "$3"
      ;;
    *)
      echoerr "wrong shutdown command: $1"
      return 1
      ;;
  esac
}

# console connects to screen session.
function console() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server is not running"; return 0
  fi

  screen -r "${SERVER_NAME}"
}

# screencmd calls the $1 command to the game using screen util.
# The screencmd function is faster than rconcmd, but you cannot get a response
# to the request. Therefore, it should be used when the answer is not needed.
function screencmd() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server is not running"; return 0
  fi

  local command="$1"
  [ -z "${command}" ] && { echoerr "command is not set"; return 1; }

  screen -S "${SCREEN_ZOMBOID}" -X stuff "${command}\r"
}

# rconcmd calls the $1 command to the game using Source RCON Protocol.
# The port and authorization parameters takes from the Project Zomboid config.
function rconcmd() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server is not running"; return 0
  fi

  local command="$1"
  [ -z "${command}" ] && { echoerr "command is not set"; return 1; }

  local timeout="$2"
  [ -z "${timeout}" ] && timeout=3s

  local host='127.0.0.1'
  local port=""
  local password=""

  port=$(grep "RCONPort=" "${ZOMBOID_FILE_CONFIG_INI}"); port=${port//RCONPort=/}; port=${port// /}
  password=$(grep "RCONPassword=" "${ZOMBOID_FILE_CONFIG_INI}"); password=${password//RCONPassword=/}; password=${password// /}

  ${UTIL_RCON_FILE} -a "${host}:${port}" -p "${password}" -T "${timeout}" "${command}"
}

# kickusers kicks all players from the server.
function kickusers() {
  local players=""
  if ! players=$(rconcmd "players"); then
    echoerr "kickusers: cannot get users"; return 0;
  fi

  local i=0

  players=$(echo "${players}" | grep ^"-")
  if [ "${players}" ]; then
    IFS=$'\n'

    declare -a a
    a=("${players}")

    for line in "${a[@]}"; do
      ((i=i+1))
      local username="${line:1}"
      screencmd "kickuser \"${username}\""
    done
  fi

  echo "${OK} kicked ${i} users"
}

# delete_mods_manifest deletes appworkshop_108600.acf file. It need to
# update mods correctly.
function delete_mods_manifest() {
  [ ! -f "${ZOMBOID_MODS_MANIFEST}" ] && return 0

  echo "${INFO} remove appworkshop_${APP_ID}.acf"
  rm "${ZOMBOID_MODS_MANIFEST}"
}

# delete_old_java_stack_traces deletes hs_err_pid*.log files that are older
# than $1 days from server root directory.
# If you do not pass the number of days $1, or pass the value 0 then the
# default value will be taken from the variable CLEAR_STACK_TRACE_DAY.
function delete_old_java_stack_traces() {
  local days="$1"
  [ -z "${days}" ] && days=${CLEAR_STACK_TRACE_DAY}

  # Do nothing if turned off in the settings.
  [ "${days}" -eq "0" ] && return

  # Remove java stack traces.
  local count
  (( days-- ))
  count=$(find "${SERVER_DIR}" -name "hs_err_pid*.log" -mtime +${days} | wc -l)
  find "${SERVER_DIR}" -name "hs_err_pid*.log" -mtime +${days} -delete
  (( days++ ))
  echo "${INFO} remove hs_err_pid*.log files older than ${days} days... ${count} files"
}

# delete_old_logs deletes log files that are older than $1 days from
# Zomboid/Logs directory.
# If you do not pass the number of days $1, or pass the value 0 then the
# default value will be taken from the variable CLEAR_LOGS_DAY.
function delete_old_logs() {
  local days="$1"
  [ -z "${days}" ] && days=${CLEAR_LOGS_DAY}

  # Do nothing if turned off in the settings.
  [ "${days}" -eq "0" ] && return 0

  # Remove old logs folders.
  local count
  (( days-- ))
  count=$(find "${ZOMBOID_DIR_LOGS}" -name "*.txt" -mtime +${days} | wc -l)
  find "${ZOMBOID_DIR_LOGS}" -name "*.txt" -mtime +${days} -delete
  (( days++ ))
  echo "${INFO} remove logs files older than ${days} days... ${count} files"

  # Remove empty logs folders.
  find "${ZOMBOID_DIR_LOGS}" -empty -type d -delete
}

# delete_zombies deletes all zpop_*_*.bin files from Zomboid/Saves directory.
# These files are responsible for placing zombies on the world.
# It is recommended to use with a turned off server. When used on a running
# server, it can create more problems than it solves.
# But it can help the game restart the threads responsible for the zombies,
# if they freeze.
# TODO: Find a way to real zombies delete.
function delete_zombies() {
  local count
  count=$(find "${ZOMBOID_DIR_MAP}" -name "zpop_*_*.bin" | wc -l)
  echo "${INFO} remove zpop_*_*.bin files... ${count} files"
  rm -rf "${ZOMBOID_DIR_MAP}/zpop_*_*.bin"
}

# delete_gos_files deletes gos_*.bin files from Zomboid/Saves directory.
function delete_gos_files() {
  rm -rf "${ZOMBOID_DIR_MAP}/gos_campfire.bin"
  rm -rf "${ZOMBOID_DIR_MAP}/gos_farming.bin"
  rm -rf "${ZOMBOID_DIR_MAP}/gos_metaldrum.bin"
  rm -rf "${ZOMBOID_DIR_MAP}/gos_rainbarrel.bin"
  rm -rf "${ZOMBOID_DIR_MAP}/gos_trap.bin"
}

# delete_old_chunks deletes files map_*_*.bin older than $1 days from
# Zomboid/Saves directory.
# If you do not pass the number of days $1, or pass the value 0 then the
# default value will be taken from the variable CLEAR_MAP_DAY.
function delete_old_chunks() {
  local days="$1"
  [ -z "${days}" ] && days=${CLEAR_MAP_DAY}

  # Do nothing if turned off in the settings.
  [ "${days}" -eq "0" ] && return 0

  local count
  (( days-- ))
  count=$(find "${ZOMBOID_DIR_MAP}" -name "map_*_*.bin" -mtime +${days} | wc -l)
  find "${ZOMBOID_DIR_MAP}" -name "map_*_*.bin" -mtime +${days} -delete
  (( days++ ))
  echo "${INFO} remove chunks older than ${days} days... ${count} chunks"
}

# get_rectangle takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them.
function get_rectangle() {
  local from="$1"
  if [ -z "${from}" ]; then
     echo "0 0 0 0 upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echo "0 0 0 0 lower left corner is not set"; return 1
  fi

  local regexp='^[0-9]+$'

  # Upper right corner.
  IFS='x' read -ra point_top <<< "${from}"
  local top_x="${point_top[0]}"
  local top_y="${point_top[1]}"
  if ! [[ ${top_x} =~ $regexp ]] || ! [[ ${top_y} =~ $regexp ]]; then
     echo "0 0 0 0 upper right corner is invalid"; return 1
  fi

  # Lower left corner.
  IFS='x' read -ra point_bot <<< "${to}"
  local bot_x="${point_bot[0]}";
  local bot_y="${point_bot[1]}"
  if ! [[ ${bot_x} =~ $regexp ]] || ! [[ ${bot_y} =~ $regexp ]]; then
     echo "0 0 0 0 lower left corner is invalid"; return 1
  fi

  echo "${top_x} ${top_y} ${bot_x} ${bot_y}"
}

# map_regen takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them and deletes them.
#
# Example: map_regen 10626x10600 10679x10661
function map_regen() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  if [ ! -d "${ZOMBOID_DIR_MAP}" ]; then
     echoerr "saves dir \"${ZOMBOID_DIR_MAP}\" doesn't exist"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))
  if [ -n "${rectangle[4]}" ]; then
    echoerr "${rectangle[*]:4}"; return 1
  fi

  # Delete last digit to convert to chunk name.
  local top_x; top_x=$(echo "${rectangle[0]}/10" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}/10" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}/10" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}/10" |bc)

  if [ "${top_x}" -gt "${bot_x}" ] || [ "${top_y}" -gt "${bot_y}" ]; then
    echoerr "invalid points"; return 1
  fi

  local count=0
  local count_success=0
  for (( x=top_x; x <= bot_x; x++ )) do
    for (( y=top_y; y <= bot_y; y++ )) do
      (( count++ ))
      local name="map_${x}_${y}.bin"
      rm "${ZOMBOID_DIR_MAP}/${name}" > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        (( count_success++ ))
      fi
    done
  done

  echo "${OK} deleted ${count_success} from ${count} chunks"
}

# map_copy takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them and copies them to
# backups/copy directory. With an additional argument, you can specify a name
# for the catalog of copied chunks. If you don't specify a name, then it will
# generated based on the coordinates.
#
# Example: map_copy 11586x8230 11639x8321
# Example: map_copy 11586x8230 11639x8321 bar
function map_copy() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  if [ ! -d "${ZOMBOID_DIR_MAP}" ]; then
     echoerr "saves dir \"${ZOMBOID_DIR_MAP}\" doesn't exist"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))
  if [ -n "${rectangle[4]}" ]; then
    echoerr "${rectangle[*]:4}"; return 1
  fi

  # Delete last digit to convert to chunk name.
  local top_x; top_x=$(echo "${rectangle[0]}/10" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}/10" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}/10" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}/10" |bc)

  if [ "${top_x}" -gt "${bot_x}" ] || [ "${top_y}" -gt "${bot_y}" ]; then
     echoerr "invalid points"; return 1
  fi

  local copy_path="${DIR_BACKUPS_COPY}"
  if [ -z "$3" ]; then
    copy_path=${copy_path}/${NOW}_${from}_${to}
  else
    copy_path=${copy_path}/${NOW}_$3
  fi

  mkdir -p "${copy_path}" #> /dev/null 2>&1
  if [ ! $? -eq 0 ]; then
    echoerr "can not create directory ${copy_path} to copy"; return 1
  fi

  local count=0
  local count_success=0
  for (( x=top_x; x <= bot_x; x++ )) do
    for (( y=top_y; y <= bot_y; y++ )) do
      (( count++ ))
      local name="map_${x}_${y}.bin"

      if [ -f "${ZOMBOID_DIR_MAP}/${name}" ]; then
        cp "${ZOMBOID_DIR_MAP}/${name}" "${copy_path}" > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          (( count_success++ ))
        else
          echoerr "can not copy chunk ${name}"
        fi
      fi
    done
  done

  echo "${OK} copied ${count_success} from ${count} chunks"
}

# map_copyto takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them and copies them to
# backups/copy directory and rename to new coordinates. With an additional
# argument, you can specify a name for the catalog of copied chunks. If you
# don't specify a name, then it will generated based on the coordinates.
#
# Example: map_copyto 9240x4800 9299x4859 11530x8200
# Example: map_copyto 9240x4800 9299x4859 11530x8200 maze
function map_copyto() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  if [ ! -d "${ZOMBOID_DIR_MAP}" ]; then
     echoerr "saves dir \"${ZOMBOID_DIR_MAP}\" doesn't exist"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))
  if [ -n "${rectangle[4]}" ]; then
    echoerr "${rectangle[*]:4}"; return 1
  fi

  # Delete last digit to convert to chunk name.
  local top_x; top_x=$(echo "${rectangle[0]}/10" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}/10" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}/10" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}/10" |bc)

  if [ "${top_x}" -gt "${bot_x}" ] || [ "${top_y}" -gt "${bot_y}" ]; then
     echoerr "invalid points"; return 1
  fi

  local from_new="$3"
  local regexp='^[0-9]+$'

  IFS='x' read -ra point_top <<< "${from_new}"
  local top_x_new; top_x_new=$(echo "${point_top[0]}/10" |bc)
  local top_y_new; top_y_new=$(echo "${point_top[1]}/10" |bc)

  if ! [[ ${top_x_new} =~ $regexp ]] || ! [[ ${top_y_new} =~ $regexp ]]; then
     echoerr "upper new point is invalid"; return 1
  fi

  local copy_path="${DIR_BACKUPS_COPY}"
  if [[ -z "$4" ]]; then
    copy_path="${copy_path}/${NOW}_${from_new}"
  else
    copy_path="${copy_path}/${NOW}_$4"
  fi

  mkdir -p "${copy_path}" #> /dev/null 2>&1
  if [[ ! $? -eq 0 ]]; then
    echoerr "can not create directory ${copy_path} to copy"; return 1
  fi

  local x_new="${top_x_new}"

  local count=0
  local count_success=0
  for (( x=top_x; x <= bot_x; x++ )) do
    local y_new="${top_y_new}"

    for (( y=top_y; y <= bot_y; y++ )) do
      (( count++ ))

      local name="map_${x}_${y}.bin"
      local name_new="map_${x_new}_${y_new}.bin"

      cp "${ZOMBOID_DIR_MAP}/${name}" "${copy_path}/${name_new}" > /dev/null 2>&1
      if [[ $? -eq 0 ]]; then
        (( count_success++ ))
      else
        echoerr "can not copy chunk ${name}"
      fi

      (( y_new++ ))
    done

    (( x_new++ ))
  done

  echo "${OK} copied ${count_success} from ${count} chunks"
}

# range takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them for generating regexp rule
# for searching the log.
#
# Example range 4251x5869 4270x5884
# > (425[1-9]|426[0-9]|4270),(5869|587[0-9]|588[0-4])
function range() {
  if [ ! -f "${UTIL_RANGE_FILE}" ]; then
     echoerr "util range.sh is not found"; return 1
  fi

  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))
  if [ -n "${rectangle[4]}" ]; then
    echoerr "${rectangle[*]:4}"; return 1
  fi

  local top_x; top_x=$(echo "${rectangle[0]}" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}" |bc)

  if [ "${top_x}" -gt "${bot_x}" ] || [ "${top_y}" -gt "${bot_y}" ]; then
     echoerr "invalid points"; return 1
  fi

  local range_x; range_x=$(${UTIL_RANGE_FILE} "${top_x}" "${bot_x}")
  local range_y; range_y=$(${UTIL_RANGE_FILE} "${top_y}" "${bot_y}")

  echo "${range_x},${range_y}"
}

# backup copies server files to backup directory.
# After successful copying, check for old backups and delete them.
function backup() {
  NOW=$(date "+%Y%m%d_%H%M%S")
  local type="$1"

  if [ "${type}" == "fast" ]; then
    time_machine_save "$NOW" && return 0 || return 1
  fi

  if [ "${type}" == "players" ]; then
    players_save "$NOW" && return 0 || return 1
  fi

  if [ "${type}" == "world" ]; then
    zomboid_save "$NOW" && return 0 || return 1
  fi

  if [ "${type}" == "pzlsd" ]; then
    pzlsd_save "$NOW" && return 0 || return 1
  fi

  echoerr "unknown backup \"${type}\" command"
}

# config_pull downloads Project Zomboid config files from github repo.
function config_pull() {
  if [ -z "${GITHUB_ACCESS_TOKEN}" ] || [ -z "${GITHUB_CONFIG_REPO}" ]; then
    echoerr "github repo or token is not set"; return 1
  fi

  local cfg_ini=""
  cfg_ini=$(curl -H "Authorization: token ${GITHUB_ACCESS_TOKEN}" -s -L "${GITHUB_CONFIG_REPO}/${SERVER_NAME}/${SERVER_NAME}.ini")
  if [ "$(echo "${cfg_ini}" | wc -l)" -lt "100" ]; then
    echoerr "downloaded invalid ${SERVER_NAME}.ini";  return 1
  fi;

  local cfg_sand=""
  cfg_sand=$(curl -H "Authorization: token ${GITHUB_ACCESS_TOKEN}" -s -L "${GITHUB_CONFIG_REPO}/${SERVER_NAME}/${SERVER_NAME}_SandboxVars.lua")
  if [ "$(echo "${cfg_sand}" | wc -l)" -lt "100" ]; then
    echoerr "downloaded invalid ${SERVER_NAME}_SandboxVars.lua";  return 1
  fi;

  local cfg_points=""
  cfg_points=$(curl -H "Authorization: token ${GITHUB_ACCESS_TOKEN}" -s -L "${GITHUB_CONFIG_REPO}/${SERVER_NAME}/${SERVER_NAME}_spawnpoints.lua")
  if [ "$(echo "${cfg_points}" | wc -l)" -lt "7" ]; then
    echoerr "downloaded invalid ${SERVER_NAME}_spawnpoints.lua";  return 1
  fi;

  local cfg_regions=""
  cfg_regions=$(curl -H "Authorization: token ${GITHUB_ACCESS_TOKEN}" -s -L "${GITHUB_CONFIG_REPO}/${SERVER_NAME}/${SERVER_NAME}_spawnregions.lua")
  if [ "$(echo "${cfg_regions}" | wc -l)" -lt "10" ]; then
    echoerr "downloaded invalid ${SERVER_NAME}_spawnregions.lua";  return 1
  fi;

  echo "${cfg_ini}" > "${ZOMBOID_FILE_CONFIG_INI}"
  echo "${cfg_sand}" > "${ZOMBOID_FILE_CONFIG_SANDBOX}"
  echo "${cfg_points}" > "${ZOMBOID_FILE_CONFIG_SPAWNPOINTS}"
  echo "${cfg_regions}" > "${ZOMBOID_FILE_CONFIG_SPAWNREGIONS}"

  echo "${OK} config downloaded"
}

# time_machine_save saves database files to backup folder.
function time_machine_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "fast world save on ${NOW} failed";
  }

  # delete_old_time_machines deletes files servername_date_time.tar.gz older
  # than $1 days from backups/timemachine directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_TIME_MACHINE_DAY.
  delete_old_time_machines() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_TIME_MACHINE_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_TIME_MACHINE}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_TIME_MACHINE}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove time machine backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} fast world saving on ${NOW}..."

  local machine_name="${SERVER_NAME}_${NOW}"
  local machine_path="${DIR_BACKUPS_TIME_MACHINE}/${machine_name}"

  if ! mkdir -p "${machine_path}"; then
    echoerr "fast world save on ${NOW} failed"; return 1
  fi

  echo "${INFO} backup players.db..."
  if ! cp "${ZOMBOID_DIR_MAP}/players.db" "${machine_path}/players.db"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup vehicles.db..."
  if ! cp "${ZOMBOID_DIR_MAP}/vehicles.db" "${machine_path}/vehicles.db"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup WorldDictionary.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/WorldDictionary.bin" "${machine_path}/WorldDictionary.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup map_meta.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/map_meta.bin" "${machine_path}/map_meta.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup map_t.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/map_t.bin" "${machine_path}/map_t.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup map_zone.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/map_zone.bin" "${machine_path}/map_zone.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup ${SERVER_NAME}.db..."
  if ! cp "${ZOMBOID_FILE_DB}" "${machine_path}/${SERVER_NAME}.db"; then
    echoerr_del "${machine_path}"; return 1
  fi

  if ! tar -czf "${machine_path}.tar.gz" -C "${DIR_BACKUPS_TIME_MACHINE}" "${machine_name}"; then
    echoerr_del "${machine_path}"; return 1
  fi

  rm -rf "${machine_path}"

  echo "${OK} fast world save on ${NOW} completed"
  delete_old_time_machines "${CLEAR_TIME_MACHINE_DAY}"
}

# players_save saves players database file to backup folder.
function players_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "players database save on ${NOW} failed";
  }

  # delete_old_players deletes files players_*_*.db older than $1 days from
  # backups/players directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_TIME_MACHINE_DAY.
  delete_old_players() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_TIME_MACHINE_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_PLAYERS}" -name "players_*_*.db" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_PLAYERS}" -name "players_*_*.db" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove players backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} backup players.db..."

  local name="players_${NOW}.db"
  if ! cp "${ZOMBOID_DIR_MAP}/players.db" "${DIR_BACKUPS_PLAYERS}/${name}"; then
    echoerr_del "${DIR_BACKUPS_PLAYERS}/${name}"; return 1
  fi

  echo "${OK} backup ${name} created successful"
  delete_old_players "${CLEAR_TIME_MACHINE_DAY}"
}

# zomboid_save saves Zomboid folder file to backup folder.
function zomboid_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "world save on ${NOW} failed";
  }

  # delete_old_zomboid deletes files ${SERVER_NAME}_*_*.tar.gz older than
  # $1 days from backups/zomboid directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_BACKUPS_DAY.
  delete_old_zomboid() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_BACKUPS_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_ZOMBOID}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_ZOMBOID}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove world backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} world save on ${NOW}..."

  local name="${SERVER_NAME}_${NOW}.tar.gz"
  if ! tar -czf "${DIR_BACKUPS_ZOMBOID}/${name}" --warning=no-file-changed -C "${ZOMBOID_DIR}" .; then
    echoerr_del "${DIR_BACKUPS_ZOMBOID}/${name}"; return 1
  fi

  echo "${OK} world save on ${NOW} completed"
  delete_old_zomboid "${CLEAR_BACKUPS_DAY}"
}

# pzlsd_save saves pzlsd folder file to backup folder.
function pzlsd_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "pzlsd save on ${NOW} failed";
  }

  # delete_old_pzlsm deletes files ${SERVER_NAME}_pzlsm_*_*.tar.gz older than
  # $1 days from backups/pzlsm directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_BACKUPS_DAY.
  delete_old_pzlsd() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_BACKUPS_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_PZLSD}" -name "${SERVER_NAME}_pzlsd_*_*.tar.gz" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_PZLSD}" -name "${SERVER_NAME}_pzlsd_*_*.tar.gz" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove pzlsd backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} pzlsd save on ${NOW}..."

  local name="${SERVER_NAME}_pzlsd_${NOW}.tar.gz"
  if ! tar -czf "${DIR_BACKUPS_PZLSD}/${name}" --warning=no-file-changed -C "${DIR_PZLSD}" .; then
    echoerr_del "${DIR_BACKUPS_PZLSD}/${name}"; return 1
  fi

  echo "${OK} pzlsd save on ${NOW} completed"
  delete_old_pzlsd "${CLEAR_BACKUPS_DAY}"
}

# log_search looks for string $1 in log files. Chat logs excluded from search.
# Using the optional parameter $2, you can specify the name of the log file to
# search.
#
# Example: log_search outdead
# Example: log_search outdead user
# Example: log_search outdead user connected
function log_search() {
  if [ -z "$1" ]; then
     echoerr "search param is not set"; return 1
  fi

  local filename="$2"
  if [ -z "${filename}" ]; then
    #grep --exclude=*_chat.txt -rIah -E "$1" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
    grep --exclude=*_chat.txt --exclude=*_DebugLog-server.txt -rIah -E "$1" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
    return 0
  fi

  local action="$3"
  if [ -z "${action}" ]; then
    grep --include=*_"${filename}".txt -rIah -E "$1" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
    return 0
  fi

  local limit="$4"
  if [ -n "${limit}" ]; then
    grep --include=*_"${filename}".txt -rIah -E "$1\"? ${action}" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3 | tail -n "${limit}"
  else
    grep --include=*_"${filename}".txt -rIah -E "$1\"? ${action}" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
  fi
}

# clog_search looks for string $1 in current log files. Chat logs excluded
# from search. Using the optional parameter $2, you can specify the name of
# the log file to search.
#
# Example: log_search outdead
# Example: log_search outdead user
# Example: log_search outdead user connected
function clog_search() {
  if [ -z "$1" ]; then
     echoerr "search param is not set"; return 1
  fi

  local filename="$2"
  if [ -z "${filename}" ]; then
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -not -iname "*_DebugLog-server.txt" -not -iname "*_chat.txt" -exec grep -E "$1" {} \; | sort
    return 0
  fi

  local action="$3"
  if [ -z "${action}" ]; then
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -iname "*_${filename}.txt" -exec grep -E "$1" {} \; | sort
    return 0
  fi

  local limit="$4"
  if [ -n "${limit}" ]; then
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -iname "*_${filename}.txt" -exec grep -E "$1\"? ${action}" {} \; | tail -n "${limit}" | sort
  else
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -iname "*_${filename}.txt" -exec grep -E "$1\"? ${action}" {} \; | sort
  fi
}

# fn_sqlite executes query 1 to the Project Zomboid database and displays result.
#
# Example: fn_sqlite 'select * from whitelist limit 1'
function fn_sqlite() {
  local query="$2"
  if [ -z "${query}" ]; then
     echoerr "query param is not set"; return 1
  fi

  case "$1" in
    whitelist)
      sqlite3 "${ZOMBOID_FILE_DB}" "${query}" ;;
    players)
      sqlite3 "${ZOMBOID_FILE_PLAYERS_DB}" "${query}" ;;
    vehicles)
      sqlite3 "${ZOMBOID_FILE_VEHICLES_DB}" "${query}" ;;
    *)
      echoerr "unknown db param \"$1\""; return 1 ;;
  esac
}

# fn_vehicles prints vehicles coordinates.
function fn_vehicles() {
  sqlite3 -separator ',' "${ZOMBOID_FILE_VEHICLES_DB}" "SELECT cast(round(x) as int) as x, cast(round(y) as int) as y, 0 as z FROM vehicles;"
}

# players_restore replaces players.db database from backup.
function players_restore() {
  local filename="$1"
  if [ -z "${filename}" ]; then
     echoerr "backup filename param is not set"; return 1
  fi

  local path="${DIR_BACKUPS_PLAYERS}/${filename}"
  if [ ! -f "${path}" ]; then
    echoerr "players backup ${filename} does not exist"; return 1
  fi

  if [ "$(is_server_running)" == "true" ]; then
    echoerr "cannot be executed on a running server"; return 1
  fi

  if ! cp "${path}" "${ZOMBOID_DIR_MAP}/players.db"; then
    echoerr "players backup ${filename} was not restored"; return 1
  fi

  echo "${OK} players backup ${filename} restored successful"
}

# self_update downloads PZLSM updates from repository.
# TODO: Add chose tags: version|latest|develop.
function self_update() {
  local update_dir="${DIR_STATE}/update"

  rm -rf "${update_dir}"
  mkdir -p "${update_dir}"

  wget -q -O "${update_dir}/server.sh" "${PZLSM_SOURCE_LINK}/server.sh" && chmod +x "${update_dir}/server.sh"

  local new_version; new_version=$(grep "^VERSION" "${update_dir}/server.sh" | awk -F'[="]' '{print $3}')

  if [ -z "${new_version}" ]; then
    echoerr "Failed to download PZLSM update"; return 1
  fi

  if [ "${VERSION}" \< "${new_version}" ]; then
    mv "${update_dir}/server.sh" "${SCRIPT_LOCATION}/server.sh"
    echo "${INFO} PZLSM successfully updated"
  else
    echo "${INFO} Nothing to update"
  fi

  rm -rf "${update_dir}"
}

PLUGINS_COMMANDS_HELP=""

IFS=';' read -ra ADDR <<< "${DIR_PLUGINS}"
for i in "${ADDR[@]}"; do
  for f in "${i}"/*.sh ; do
    test -f "${f}" && {
      if grep -E '^[[:space:]]*([[:alnum:]_]+[[:space:]]*\(\)|function[[:space:]]+[[:alnum:]_]+)' "${f}" | grep -w main > /dev/null; then
        echoerr "broken plugin $(basename "${f}")"; exit 1
      fi

      if grep -E '^[[:space:]]*([[:alnum:]_]+[[:space:]]*\(\)|function[[:space:]]+[[:alnum:]_]+)' "${f}" | grep -w load > /dev/null; then
        . "${f}";

        if [ -n "$CMD" ]; then
          IFS=' ' read -ra args <<< "${CMD}"
          load "${args[@]}"
        else
          load "$@"
        fi
      fi
    }
  done
done

function print_help() {
  echo "NAME:"
  echo "  pzlsm - Terminal tool for manage Project Zomboid server on Linux"
  echo ""
  echo "USAGE:"
  echo "  $0 [global options] command [arguments...] [options]"
  echo ""
  echo "VERSION:"
  echo "  ${VERSION}"
  echo
  echo "DESCRIPTION:"
  echo "  Tool kit for installation and management of Project Zomboid dedicated servers on Linux"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --variables, --vars     Print variables."
  echo "  --version               Print the version."
  echo "  --help                  Show help."
  echo
  echo "COMMANDS:"
  echo "  self-update             Updates PZLSM."
  echo "  install [args]          Installs Project Zomboid dedicated server."
  echo "  update                  Updates Project Zomboid dedicated server."
  echo "  config [args]           Manipulates with server config."
  echo "  start [args]            Starts the server in a screen window. An error message will"
  echo "                          be displayed if server has been started earlier."
  echo "  stop [args]             Stops the server. Triggers informational messages for players"
  echo "                          to alert them of impending server shutdown."
  echo "  restart [args]          Restarts the server. Triggers informational messages for players"
  echo "                          to alert them of impending server shutdown."
  echo "  autorestart             Restarts server if it stuck an backups last logs."
  echo "  stats [args]            Contains presets to OS statistics. Keep sub command empty"
  echo "                          to use default action. Displays information on the peak"
  echo "                          processor consumption and current RAM consumption."
  echo "  cmd [args]              Executes the 1 argument as a command on the game server."
  echo "  kickusers               Kicks all players from the server."
  echo "  delfile [args]          Deletes selected Project Zomboid files."
  echo "  map [args]              Manipulates with map chunk files."
  echo "  range [args]            Takes the coordinates of the upper right and lower left points"
  echo "                          and builds a rectangular area of chunks from them for generating regexp"
  echo "                          rule for searching the log."
  echo "  backup [args]           Copies server files to backup directory. After successful copying, check"
  echo "                          for old backups and delete them."
  echo "  log [args]              Looks for string 1 in log files. Chat logs excluded from search."
  echo "                          Using the optional parameter 2, you can specify the name of the log"
  echo "                          file to search."
  echo "  sql [args]              Executes query 1 to the Project Zomboid database and displays result."
  echo "  players [args]          Manipulates with players database."
  echo "  vehicles [args]         Manipulates with vehicles database."
  echo
  echo "PLUGINS:"
  echo "  ${PLUGINS_COMMANDS_HELP}"
  echo
  echo "COPYRIGHT:"
  echo "  Copyright (c) ${YEAR} ${AUTHOR}"
}

function print_help_install() {
  echo "COMMAND NAME:"
  echo "  install"
  echo
  echo "DESCRIPTION:"
  echo "  Installs Project Zomboid dedicated server and necessary dependencies."
  echo "  Keep sub commands empty to install all is necessary."
  echo
  echo "USAGE:"
  echo "  $0 install command [arguments...] [options...]"
  echo
  echo "OPTIONS:"
  echo "  --branch|-b       Specifies branch name to install the game. Can take the"
  echo "                    following values: none, beta, unstable (Default = none)."
  echo "  --no-fixes|-n     Do not apply fixes after server installation."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 install"
  echo "  $0 install -b none"
  echo "  $0 install -b unstable -n"
  echo
  echo "COMMANDS:"
  echo "  dependencies      Installs necessary dependencies to the server."
  echo "  EXAMPLE:"
  echo "    $0 install dependencies"
  echo
  echo "  folders           Creates necessary folders for pzlsm script."
  echo "  EXAMPLE:"
  echo "    $0 install folders"
  echo
  echo "  utils             Installs additional utils to the server."
  echo "  EXAMPLE:"
  echo "    $0 install utils"
  echo
  echo "  prepare           Installs necessary dependencies, additional utils to"
  echo "                    the server and creates necessary folders for pzlsm script."
  echo "  EXAMPLE:"
  echo "    $0 install prepare"
  echo
  echo "  server            Installs only Project Zomboid dedicated server."
  echo "  OPTIONS:"
  echo "    --branch|-b     Specifies branch name to install the game. Can take the"
  echo "                    following values: none, beta, unstable (Default = none)."
  echo "    --no-fixes|-n   Do not apply fixes after server installation."
  echo "  EXAMPLE:"
  echo "    $0 install server -b unstable"
  echo "    $0 install server -b unstable -n"
  echo "    $0 install server -n"
  echo
  echo "  fix               Only apply fixes (Changes game language to EN and sets"
  echo "                    Project Zomboid args)."
  echo "  EXAMPLE:"
  echo "    $0 install fix"
}

function print_help_update() {
  echo "COMMAND NAME:"
  echo "  update"
  echo
  echo "DESCRIPTION:"
  echo "  Updates Project Zomboid dedicated server."
  echo
  echo "USAGE:"
  echo "  $0 update command [arguments...] [options...]"
  echo
  echo "OPTIONS:"
  echo "  --no-fixes|-n     Do not apply fixes after server installation."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 update"
  echo "  $0 update -n"
}

function print_help_config() {
  echo "COMMAND NAME:"
  echo "  config"
  echo
  echo "DESCRIPTION:"
  echo "  Contains commands for manipulating server config."
  echo
  echo "USAGE:"
  echo "  $0 config subcommand [arguments...] [options...]"
  echo
  echo "SUBCOMMANDS:"
  echo "  pull        Downloads Project Zomboid config files from github repo."
  echo "              Be careful - old PZ config files will be rewritten."
  echo "  EXAMPLE:"
  echo "    $0 config pull"
}

function print_help_start() {
  echo "COMMAND NAME:"
  echo "  start"
  echo
  echo "DESCRIPTION:"
  echo "  Starts Project Zomboid dedicated server."
  echo
  echo "USAGE:"
  echo "  $0 start [arguments...] [options...]"
  echo
  echo "OPTIONS:"
  echo "  --no-screen|-n    Runs server without screen session."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 start"
  echo "  $0 start -n"
}

function print_help_stop() {
  echo "COMMAND NAME:"
  echo "  stop"
  echo
  echo "DESCRIPTION:"
  echo "  Stops Project Zomboid dedicated server in 5 minutes."
  echo "  You can change timer period with arguments \"now\" and \"kill\"."
  echo
  echo "USAGE:"
  echo "  $0 stop [arguments...] [options...]"
  echo
  echo "ARGUMENTS:"
  echo "  fix               Delete mods manifest file for force update mods. DEPRECATED, use --fixes option."
  echo "  now               Stops server in 10 seconds."
  echo "  kill              Stops the server immediately."
  echo
  echo "OPTIONS:"
  echo "  --fixes|-f        Delete mods manifest file for force update mods."
  echo "  --no-tasks|-n     Do not backups and other tasks. Poor stop."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 stop"
  echo "  $0 stop -f"
  echo "  $0 stop now -f"
  echo "  $0 stop -f kill"
}

function print_help_restart() {
  echo "COMMAND NAME:"
  echo "  restart"
  echo
  echo "DESCRIPTION:"
  echo "  Restarts Project Zomboid dedicated server in 5 minutes."
  echo "  You can change timer period with arguments \"now\" and \"kill\"."
  echo
  echo "USAGE:"
  echo "  $0 restart [arguments...] [options...]"
  echo
  echo "ARGUMENTS:"
  echo "  fix               Delete mods manifest file for force update mods. DEPRECATED, use --fixes option."
  echo "  now               Restarts server in 10 seconds."
  echo "  kill              Restarts the server immediately."
  echo
  echo "OPTIONS:"
  echo "  --fixes|-f        Delete mods manifest file for force update mods."
  echo "  --no-tasks|-n     Do not backups and other tasks. Poor restart."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 restart"
  echo "  $0 restart -f"
  echo "  $0 restart now -f"
  echo "  $0 restart -f kill"
}

function print_help_stats() {
  echo "COMMAND NAME:"
  echo "  stats"
  echo
  echo "DESCRIPTION:"
  echo "  Contains presets to OS statistics. Keep sub command empty"
  echo "  to use default action. Displays information on the peak"
  echo "  processor consumption and current RAM consumption."
  echo
  echo "USAGE:"
  echo "  $0 stats subcommand [arguments...] [options...]"
  echo
  echo "SUBCOMMANDS:"
  echo "  info     Displays information on the peak processor consumption and"
  echo "           current RAM consumption (Default command)."
  echo "  EXAMPLE:"
  echo "    $0 stats info"
  echo "    $0 stats"
  echo
  echo "  top      Prints list of top processes with memory usage."
  echo "  OPTIONS:"
  echo "    --number|-n     Number of lines (default=10)."
  echo "  EXAMPLE:"
  echo "    $0 stats top -n 10"
}

function print_help_cmd() {
  echo "COMMAND NAME:"
  echo "  cmd"
  echo
  echo "DESCRIPTION:"
  echo "  Executes command on the game server. To see list of allowed commands"
  echo "  execute $0 cmd help."
  echo
  echo "USAGE:"
  echo "  $0 cmd command [options...]"
  echo
  echo "OPTIONS:"
  echo "  --rcon|-r         Use RCON protocol. Prints response in terminal. Used by default."
  echo "  --screen|-s       Sends command to screen session. No response. Faster then rcon, "
  echo "                    can work when rcon is not enabled."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 cmd players"
  echo "  $0 cmd players -r"
  echo "  $0 cmd quit -s"
  echo "  $0 cmd \"banuser TestUser\""
  echo "  $0 cmd 'banuser \"Test User\"'"
}

function print_help_delfile() {
  echo "COMMAND NAME:"
  echo "  delfile"
  echo
  echo "DESCRIPTION:"
  echo "  Deletes selected Project Zomboid files."
  echo
  echo "USAGE:"
  echo "  $0 delfile [global options...] command [arguments...]"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "COMMANDS:"
  echo "  manifest          Deletes appworkshop_108600.acf file. It need to"
  echo "                    update mods correctly."
  echo "  EXAMPLE:"
  echo "    $0 delfile manifest"
  echo
  echo "  zombies           Deletes all zpop_*_*.bin files from Zomboid/Saves directory."
  echo "                    These files are responsible for placing zombies on the world."
  echo "                    It is recommended to use with a turned off server. When used on"
  echo "                    a running server, it can create more problems than it solves."
  echo "  EXAMPLE:"
  echo "    $0 delfile zombies"
  echo
  echo "  map {top} {bottom}  Deletes map_*_*.bin files from Zomboid/Saves directory."
  echo "                      Takes the coordinates of the upper right and lower left points"
  echo "                      and builds a rectangular area of chunks from them and deletes them."
  echo "  ARGUMENTS:"
  echo "    top             The upper right XY point with 'x' delimiter."
  echo "    bottom          The lower left XY point with 'x' delimiter."
  echo "  EXAMPLE:"
  echo "    $0 delfile map 10626x10600 10679x10661"
}

function print_help_map() {
  echo "COMMAND NAME:"
  echo "  map"
  echo
  echo "DESCRIPTION:"
  echo "  Manipulates with map chunk files."
  echo
  echo "USAGE:"
  echo "  $0 map [global options...] command [arguments...]"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "COMMANDS:"
  echo "  delete {top} {bottom}  Deletes map_*_*.bin files from Zomboid/Saves directory."
  echo "                         Takes the coordinates of the upper right and lower left points"
  echo "                         and builds a rectangular area of chunks from them and deletes them."
  echo "  ARGUMENTS:"
  echo "    top             The upper right XY point with 'x' delimiter."
  echo "    bottom          The lower left XY point with 'x' delimiter."
  echo "  EXAMPLE:"
  echo "    $0 map delete 10626x10600 10679x10661"
  echo
  echo "  copy {top} {bottom}  Copies map_*_*.bin files from Zomboid/Saves directory."
  echo "                       Takes the coordinates of the upper right and lower left points"
  echo "                       and builds a rectangular area of chunks from them and copies them"
  echo "                       to backups/copy directory."
  echo "  ARGUMENTS:"
  echo "    top             The upper right XY point with 'x' delimiter."
  echo "    bottom          The lower left XY point with 'x' delimiter."
  echo "  OPTIONS:"
  echo "    --name          Specifies a name for the catalog of copied chunks. If you don't"
  echo "                    specify a name, then it will generated based on the coordinates."
  echo "    --to            Renames chunks for new top point."
  echo "  EXAMPLE:"
  echo "    $0 map copy 11591x8239 11620x8270"
  echo "    $0 map copy 11591x8239 11620x8270 --name bar"
  echo "    $0 map copy 10626x10600 10679x10661 --name Gas-2-Go --to 10696x10619"
}

function print_help_range() {
  echo "COMMAND NAME:"
  echo "  range"
  echo
  echo "DESCRIPTION:"
  echo "  Takes the coordinates of the upper right and lower left points"
  echo "  and builds a rectangular area of chunks from them for generating regexp"
  echo "  rule for searching the log."
  echo
  echo "USAGE:"
  echo "  $0 range [global options...] {top} {bottom}"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "ARGUMENTS:"
  echo "  top               The upper right XY point with 'x' delimiter."
  echo "  bottom            The lower left XY point with 'x' delimiter."
  echo
  echo "EXAMPLE:"
  echo "  $0 range 10626x10600 10679x10661"
}

function print_help_backup() {
  echo "COMMAND NAME:"
  echo "  backup"
  echo
  echo "DESCRIPTION:"
  echo "  Copies server files to backup directory. After successful copying, checks"
  echo "  for old backups and delete them."
  echo
  echo "USAGE:"
  echo "  $0 backup [global options...] argument"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "ARGUMENTS:"
  echo "  fast              Saves database files to backup folder."
  echo "  players           Saves players database file to backup folder."
  echo "  world             Saves Zomboid folder file to backup folder."
  echo "  pzlsd             Saves pzlsd folder file to backup folder."
  echo
  echo "EXAMPLE:"
  echo "  $0 backup fast"
  echo "  $0 backup players"
  echo "  $0 backup world"
}

function print_help_log() {
  echo "COMMAND NAME:"
  echo "  log"
  echo
  echo "DESCRIPTION:"
  echo "  Looks for string in log files. Chat logs excluded from search."
  echo "  Using the optional parameter 2, you can specify the name of the log"
  echo "  file to search"
  echo
  echo "USAGE:"
  echo "  $0 log [global options...] {search} {type}"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  -a|--action       Set log action (\"fully connected\"|disconnected|died)."
  echo "  -c|--current      Search only in current server start logs."
  echo "  -l|--limit        Set limit to returned records."
  echo "  --help            Prints help end exit."
  echo
  echo "ARGUMENTS:"
  echo "  search            Needle string."
  echo "  type              Log filename type (DebugLog-server|chat|connection|user|cmd|pvp|kick|ClientActionLog|admin|item|map). Not required."
  echo
  echo "EXAMPLE:"
  echo "  $0 log outdead"
  echo "  $0 log outdead user"
  echo "  $0 log outdead user -a \"fully connected\""
  echo "  $0 log -c outdead user -a disconnected -l 2"
}

function print_help_sql() {
  echo "COMMAND NAME:"
  echo "  sql"
  echo
  echo "DESCRIPTION:"
  echo "  Executes query to the Project Zomboid database and displays result."
  echo
  echo "USAGE:"
  echo "  $0 sql [global options...] query"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --db              Select database. Possible values: whitelist|players|vehicles (default=whitelist)."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 sql \"SELECT * FROM bannedid ORDER BY steamid;\""
  echo "  $0 sql \"SELECT steamid, count(username) AS c, group_concat(username) FROM whitelist WHERE steamid != '' GROUP BY steamid HAVING c > 2 ORDER BY c DESC;\""
  echo "  $0 sql --db whitelist \"SELECT count(*) FROM whitelist;\""
  echo "  $0 sql --db players \"SELECT count(*) FROM networkPlayers;\""
  echo "  $0 sql --db vehicles \"SELECT count(*) FROM vehicles;\""
}

function print_help_players() {
  echo "COMMAND NAME:"
  echo "  players"
  echo
  echo "DESCRIPTION:"
  echo "  Manipulates with players database."
  echo
  echo "USAGE:"
  echo "  $0 players [global options...] command [arguments...] [options...]"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "COMMANDS:"
  echo "  backups           Show players.db available backups."
  echo "  OPTIONS:"
  echo "    -1              Print every backup name on new line."
  echo "  EXAMPLE:"
  echo "    $0 players backups"
  echo "    $0 players backups -1"
  echo
  echo "  restore {backup}  Replaces players.db database from backup."
  echo "  EXAMPLE:"
  echo "    $0 players restore players_20220909_050001.db"
  echo
  echo "  sql {query}       Executes SQL query on players.db database."
  echo "  EXAMPLE:"
  echo "    $0 players sql \"SELECT count(*) FROM networkPlayers;\""
}

function print_help_vehicles() {
  echo "COMMAND NAME:"
  echo "  vehicles"
  echo
  echo "DESCRIPTION:"
  echo "  Manipulates with vehicles database."
  echo
  echo "USAGE:"
  echo "  $0 vehicles [global options...] command [arguments...] [options...]"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "COMMANDS:"
  echo "  list              Prints vehicles coordinates."
  echo "  EXAMPLE:"
  echo "    $0 vehicles list"
  echo
  echo "  sql {query}       Executes SQL query on vehicles.db database."
  echo "  EXAMPLE:"
  echo "    $0 vehicles sql \"SELECT count(*) FROM vehicles;\""
}

# main contains a proxy for entering permissible functions.
function main() {
  case "$1" in
    self-update)
      self_update ;;
    install)
      local branch="none"
      local fixes="true"

      while [[ -n "$2" ]]; do
        case "$2" in
          --branch|-b) branch="$3" ;;
          --no-fixes|-n) fixes="false" ;;
          dependencies|dep)
            echo "${INFO} Installing dependencies.."

            install_dependencies
            return ;;
          folders)
            echo "${INFO} Creating required folders.."

            create_folders
            return ;;
          utils)
            echo "${INFO} Installing additional utils.."

            install_range_builder
            install_rcon
            return ;;
          prepare)
            echo "${INFO} Installing dependencies, additional utils and creating required folders.."

            install_dependencies
            create_folders
            install_range_builder
            install_rcon
            return ;;
          server)
            if [ "$(is_server_running)" == "true" ]; then
              echo "${ER} cannot install on started server"; return 0
            fi

            while [[ -n "$3" ]]; do
              case "$3" in
                --branch|-b) branch="$4" ;;
                --no-fixes|-n) fixes="false" ;;
              esac

              shift
            done

            echo "${INFO} Installing only Project Zomboid server from \"${branch}\" branch.."

            install_server "${branch}"
            if [ "${fixes}" == "true" ]; then
              fix_options
              fix_args
            fi
            return ;;
          --help)
            print_help_install
            return ;;
          fix)
            if [ "$(is_server_running)" == "true" ]; then
              echo "${ER} cannot install on started server"; return 0
            fi

            echo "${INFO} Apply fixes.."
            fix_options
            fix_args
            return ;;
        esac

        shift
      done

      if [ "$(is_server_running)" == "true" ]; then
        echo "${ER} cannot install on started server"; return 0
      fi

      echo "${INFO} Installing dependencies, additional utils, creating required folders and installs PZ server.."
      install_dependencies
      create_folders
      install_range_builder
      install_rcon
      install_server "${branch}"
      if [ "${fixes}" == "true" ]; then
        fix_options
        fix_args
      fi ;;
    update)
      if [ "$(is_server_running)" == "true" ]; then
        echo "${ER} cannot update on started server"; return 0
      fi

      local fixes="true"

      while [[ -n "$2" ]]; do
        case "$2" in
          --no-fixes|-n) fixes="false" ;;
          --help)
            print_help_update
            return ;;
        esac

        shift
      done

      echo "${INFO} Updating Project Zomboid server.."

      update_server

      if [ "${fixes}" == "true" ]; then
        fix_options
        fix_args
      fi ;;
    config)
      case "$2" in
        pull)
          config_pull ;;
        --help|*)
          print_help_config ;;
      esac ;;
    start)
      local no_screen="false"

      while [[ -n "$2" ]]; do
        case "$2" in
          --no-screen|-n) no_screen="true";;
          --help)
            print_help_start
            return ;;
        esac

        shift
      done

      start "${no_screen}";;
    stop)
      local when
      local fixes

      while [[ -n "$2" ]]; do
        case "$2" in
          now|kill) when="$2";;
          --fixes|-f|fix) fixes="fix";;
          --no-tasks|-n) NO_TASKS_ON_STOP="true";;
          --help)
            print_help_stop
            return ;;
        esac

        shift
      done

      shutdown_wrapper "stop" "${when}" "${fixes}";;
    restart)
      local when
      local fixes

      while [[ -n "$2" ]]; do
        case "$2" in
          now|kill) when="$2";;
          --fixes|-f|fix) fixes="fix";;
          --no-tasks|-n) NO_TASKS_ON_STOP="true";;
          --help)
            print_help_restart
            return ;;
        esac

        shift
      done

      shutdown_wrapper "restart" "${when}" "${fixes}";;
    autorestart)
      autorestart ;;
    stats)
      case "$2" in
        info)
          stats;;
        top)
          local number=10

          while [[ -n "$3" ]]; do
            case "$3" in
              --number|-n) param="$4"
                number="$param"
                shift ;;
            esac

            shift
          done

          stats_top "${number}";;
        --help|*)
          if [ -z "$2" ]; then
            stats; return
          fi
          print_help_stats;;
      esac ;;
    console)
      console ;;
    cmd)
      local proto="rcon"
      local command

      while [[ -n "$2" ]]; do
        case "$2" in
          --screen|-s) proto="screen" ;;
          --rcon|-r) proto="rcon" ;;
          --help)
            print_help_cmd
            return ;;
          *)
            if [ -n "${command}" ]; then
              echoerr "to many arguments"; return
            fi
            command="$2" ;;
        esac

        shift
      done

      if [ "${proto}" == "rcon" ]; then
         rconcmd "${command}"
      else
         screencmd "${command}"
      fi ;;
    kickusers)
      kickusers;;
    delfile)
      while [[ -n "$2" ]]; do
        case "$2" in
          manifest)
            delete_mods_manifest
            return ;;
          zombies)
            delete_zombies
            return ;;
          map)
            map_regen "$3" "$4"
            return ;;
          --help|*)
            print_help_delfile
            return ;;
        esac

        shift
      done

      print_help_delfile ;;
    map)
      while [[ -n "$2" ]]; do
        case "$2" in
          delete)
            map_regen "$3" "$4"
            return ;;
          copy)
            local top="$3"
            local bottom="$4"
            local name
            local to

            while [[ -n "$5" ]]; do
              case "$5" in
                --name) name="$6";;
                --to) to="$6";;
              esac

              shift
            done

            if [ -z "${to}" ]; then
              map_copy "${top}" "${bottom}" "${name}"
            else
              map_copyto "${top}" "${bottom}" "${to}" "${name}"
            fi

            return ;;
          --help|*)
            print_help_map
            return ;;
        esac

        shift
      done

      print_help_map ;;
    range)
      if [ "$2" == "--help" ]; then
        print_help_range; return
      fi

      local top="$2"
      local bottom="$3"; [ "${bottom}" == "-" ] && bottom=$4

      range "${top}" "${bottom}" ;;
    backup)
      if [ "$2" == "--help" ]; then
        print_help_backup; return
      fi

      backup "$2" ;;
    log)
      local current="false"
      local args=()

      local action
      local limit

      shift

      if [ "$1" == "-c" ] || [ "$1" == "--current" ]; then
        current="true"
        shift
      fi

      while [[ -n "$1" ]]; do
        local double="false"

        case "$1" in
          -a|--action)
            shift && action="$1" && double="true" ;;
          -l|--limit)
            shift && limit="$1" && double="true"
            case "${limit}" in
              ''|*[!1-9]*) echoerr "invalid limit"; return ;;
            esac ;;
          --help)
            print_help_log
            return ;;
        esac

        if [ "$double" == "true" ]; then
          shift; continue
        fi

        if [ -n "$1" ]; then
          args+=("$1")
        fi

        shift
      done

      if [ -n "${args[2]}" ]; then
        print_help_log; return
      fi

      local search="${args[0]}"
      local filename="${args[1]}"

      if [ "${current}" == "false" ]; then
        log_search "${search}" "${filename}" "${action}" "${limit}"
      else
        clog_search "${search}" "${filename}" "${action}" "${limit}"
      fi ;;
    sql)
      local dbname="whitelist"
      local query

      while [[ -n "$2" ]]; do
        case "$2" in
          --db) dbname="$3"; shift ;;
          --help)
            print_help_sql
            return ;;
          *)
            if [ -n "${query}" ]; then
              echoerr "to many arguments"; return
            fi
            query="$2" ;;
        esac

        shift
      done

      fn_sqlite "${dbname}" "${query}" ;;
    players)
      while [[ -n "$2" ]]; do
        case "$2" in
          backups)
            ls "${DIR_BACKUPS_PLAYERS}" $3
            return ;;
          restore)
            players_restore "$3"
            return ;;
          sql)
            fn_sqlite "players" "${3}"
            return ;;
          --help|*)
            print_help_players
            return ;;
        esac

        shift
      done

      print_help_players ;;
    vehicles)
      while [[ -n "$2" ]]; do
        case "$2" in
          list)
            fn_vehicles
            return ;;
          sql)
            fn_sqlite "vehicles" "${3}"
            return ;;
          --help|*)
            print_help_vehicles
            return ;;
        esac

        shift
      done

      print_help_vehicles ;;
    --variables|--vars)
      print_variables;;
    --version)
      print_version;;
    --help)
      print_help;;
    --test)
      echo "test"
      ;;
  esac
}

if [ -z "$1" ]; then
  echo "${INFO} Permissible commands:"
  echo "........ --variables"
  echo "........ --version"
  echo "........ --help"
  echo "........ self-update"
  echo "........ install command [arguments...] [options...]"
  echo "........ update"
  echo "........ config command"
  echo "........ start [options...]"
  echo "........ stop [options...]"
  echo "........ restart [options...]"
  echo "........ autorestart"
  echo "........ console"
  echo "........ cmd {command}"
  echo "........ kickusers"
  echo "........ delfile command"
  echo "........ map {top} {bottom}"
  echo "........ range {top} {bottom}"
  echo "........ backup {type}"
  echo "........ log {search} {type} [options...]"
  echo "........ sql {query}"
  echo "........ players {command}"
  printf "[  >>  ] " & read CMD
fi

if [ -n "$CMD" ]; then
  IFS=' ' read -ra args <<< "${CMD}"
  main "${args[@]}"
else
  main "$@"
fi
