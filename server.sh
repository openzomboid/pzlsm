#!/bin/bash

# Project Zomboid Linux Server Manager.
#
# Copyright (c) 2022 Pavel Korotkiy (outdead).
# Use of this source code is governed by the MIT license.
#
# DO NOT EDIT THIS FILE!
#
# To change config go to config/pzlsm.cfg file.
# This file will never be updated automatically.

# VERSION of Project Zomboid Linux Server Manager.
# Follows semantic versioning, SEE: http://semver.org/.
VERSION="0.22.12"
YEAR="2022"
AUTHOR="Pavel Korotkiy (outdead)"

# Color variables. Used when displaying messages in stdout.
GREEN='\033[0;32m'; RED='\033[0;31m'; YELLOW='\033[0;33m'; BLUE='\033[0;36m'; NC='\033[0m'

# Message types. Used when displaying messages in stdout.
OK=$(echo -e "[ ${GREEN} OK ${NC} ]"); ER=$(echo -e "[ ${RED} ER ${NC} ]"); WARN=$(echo -e "[ ${YELLOW} YELLOW ${NC} ]"); INFO=$(echo -e "[ ${BLUE}INFO${NC} ]")

# Project Zomboid App ID and Dedicated Server App ID in Steam.
APP_ID=108600
APP_DEDICATED_ID=380870

BASEDIR=$(dirname "$(readlink -f "${BASH_SOURCE[@]}")")

# MEMORY_AVAILABLE is the amount of memory available on the server in MB.
MEMORY_AVAILABLE=$(free | awk 'NR==2 { printf("%.0f", $2/1024); }')

# MEMORY_USED is the amount of memory used on the server in MM.
MEMORY_USED=$(free | awk 'NR==2 { printf("%.0f", $3/1024); }')

# CPU_CORE_COUNT is the number of processors cores on the server.
CPU_CORE_COUNT=$(nproc)

# NOW is the current date and time in default format Y%m%d_%H%M%S.
# You can change format in config file.
NOW=$(date "+%Y%m%d_%H%M%S")

# TIMESTAMP is current timestamp.
TIMESTAMP=$(date "+%s")

ENV_FILE="${BASEDIR}/.env"

# Import env file if exists.
# shellcheck source=.env
test -f "${ENV_FILE}" && . "${ENV_FILE}"

# Linux Server Manager directories definitions.
DIR_BACKUPS="${BASEDIR}/backups"
DIR_UTILS="${BASEDIR}/utils"
DIR_PLUGINS="${BASEDIR}/utils/plugins"
DIR_LOGS="${BASEDIR}/logs"
DIR_CONFIG="${BASEDIR}/config"
DIR_PUBLIC="${BASEDIR}/public"
DIR_STATE="${BASEDIR}/state"

DIR_BACKUPS_DOWN="${DIR_BACKUPS}/down"
DIR_BACKUPS_ZOMBOID="${DIR_BACKUPS}/zomboid"
DIR_BACKUPS_COPY="${DIR_BACKUPS}/copy"
DIR_BACKUPS_PLAYERS="${DIR_BACKUPS}/players"
DIR_BACKUPS_TIME_MACHINE="${DIR_BACKUPS}/timemachine"

# Linux Server Manager files definitions.
FILE_PZLSM_LOG="${DIR_LOGS}/pzlsm.log"
FILE_PZLSM_CONFIG="${DIR_CONFIG}/pzlsm.cfg"
FILE_PZLSM_STATE="${DIR_STATE}/pzlsm.json"

# Import config file if exists.
# shellcheck source=config/pzlsm.cfg
test -f "${FILE_PZLSM_CONFIG}" && . "${FILE_PZLSM_CONFIG}"

BASENAME=$(basename "${BASEDIR}")

## Check config variables and set default values if not defined.
[ -z "${CLEAR_MAP_DAY}" ] && CLEAR_MAP_DAY=21
[ -z "${CLEAR_LOGS_DAY}" ] && CLEAR_LOGS_DAY=1000
[ -z "${CLEAR_STACK_TRACE_DAY}" ] && CLEAR_STACK_TRACE_DAY=1000
[ -z "${CLEAR_BACKUPS_DAY}" ] && CLEAR_BACKUPS_DAY=1000
[ -z "${CLEAR_TIME_MACHINE_DAY}" ] && CLEAR_TIME_MACHINE_DAY=5
[ -z "${UTIL_RANGE_VERSION}" ] && UTIL_RANGE_VERSION="1.0.1"
[ -z "${UTIL_RCON_VERSION}" ] && UTIL_RCON_VERSION="0.10.2"
[ -z "${SERVER_MEMORY_LIMIT}" ] && SERVER_MEMORY_LIMIT=2048
[ -z "${SERVER_NAME}" ] && SERVER_NAME="servertest"
[ -z "${SCREEN_ZOMBOID}" ] && SCREEN_ZOMBOID="${SERVER_NAME}"
[ -z "${SERVER_LANG}" ] && SERVER_LANG="en"
[ -z "${SERVER_DIR}" ] && SERVER_DIR="${BASEDIR}/projectzomboid"
[ -z "${ZOMBOID_DIR}" ] && ZOMBOID_DIR="${SERVER_DIR}/Zomboid"
[ -z "${FIRST_RUN_ADMIN_PASSWORD}" ] && FIRST_RUN_ADMIN_PASSWORD="changeme"
[ -z "${BACKUP_ON_STOP}" ] && BACKUP_ON_STOP="false"
[ -z "${AUTO_RESTORE}" ] && AUTO_RESTORE="false"

[ -z "${STEAMCMD_USERNAME}" ] && STEAMCMD_USERNAME="anonymous"
[ -z "${STEAMCMD_BETA}" ] && STEAMCMD_BETA="-beta none"

## Utils

# Numeric range regular expression builder written in bash.
# https://github.com/outdead/regex-range-builder.
UTIL_RANGE_LINK="https://github.com/outdead/regex-range-builder/archive/v${UTIL_RANGE_VERSION}.tar.gz"
UTIL_RANGE_DIR="${DIR_UTILS}/regex-range-builder-${UTIL_RANGE_VERSION}"
UTIL_RANGE_FILE="${UTIL_RANGE_DIR}/range.sh"

# Rcon client for executing queries on game server.
# https://github.com/gorcon/rcon-cli.
UTIL_RCON_LINK="https://github.com/gorcon/rcon-cli/releases/download/v${UTIL_RCON_VERSION}/rcon-${UTIL_RCON_VERSION}-amd64_linux.tar.gz"
UTIL_RCON_DIR="${DIR_UTILS}/rcon-${UTIL_RCON_VERSION}-amd64_linux"
UTIL_RCON_FILE="${UTIL_RCON_DIR}/rcon"

## Directories in Zomboid folder.

ZOMBOID_DIR_SAVES="${ZOMBOID_DIR}/Saves"
ZOMBOID_DIR_LOGS="${ZOMBOID_DIR}/Logs"
ZOMBOID_DIR_SERVER="${ZOMBOID_DIR}/Server"
ZOMBOID_DIR_DB="${ZOMBOID_DIR}/db"
ZOMBOID_DIR_MAP="${ZOMBOID_DIR_SAVES}/Multiplayer/${SERVER_NAME}"

ZOMBOID_FILE_CONFIG_INI="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}.ini"
ZOMBOID_FILE_CONFIG_SANDBOX="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}_SandboxVars.lua"
ZOMBOID_FILE_CONFIG_SPAWNPOINTS="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}_spawnpoints.lua"
ZOMBOID_FILE_CONFIG_SPAWNREGIONS="${ZOMBOID_DIR_SERVER}/${SERVER_NAME}_spawnregions.lua"
ZOMBOID_FILE_DB="${ZOMBOID_DIR_DB}/${SERVER_NAME}.db"
ZOMBOID_FILE_VEHICLES_DB="${ZOMBOID_DIR_MAP}/vehicles.db"

ZOMBOID_MANIFEST="${SERVER_DIR}/steamapps/appmanifest_${APP_DEDICATED_ID}.acf"
ZOMBOID_MODS_MANIFEST="${SERVER_DIR}/steamapps/workshop/appworkshop_${APP_ID}.acf"

if [ -f "${ZOMBOID_DIR}/server-console.txt" ]; then
  PZ_VERSION=$(grep -roE "versionNumber=[0-9]+.[0-9]+" "${ZOMBOID_DIR}/server-console.txt" | grep -Eo "[0-9]+.[0-9]+")
fi
[ -z "${PZ_VERSION}" ] && PZ_VERSION="$(echo -e "${RED}undefined${NC}")"

fn_exists() { declare -F "$1" > /dev/null; }

# echoerr prints red error message to stderr and FILE_PZLSM_LOG file.
function echoerr() {
  echo "${ER} $1"
  echo "[$(date "+%Y-%m-%d %H:%M:%S")] $0 - $1" >> "${FILE_PZLSM_LOG}"
}

# echowarn prints yellow error message to stderr and FILE_PZLSM_LOG file.
function echowarn() {
  echo "${WARN} $1"
  echo "[$(date "+%Y-%m-%d %H:%M:%S")] $0 - $1" >> "${FILE_PZLSM_LOG}"
}

# get_screen_pid prints server's pid.
function get_screen_pid() {
  ps aux | grep -v grep | grep -i "screen -U -mdS ${SCREEN_ZOMBOID} " | awk '{print $2}'
}

# get_server_pid prints server's pid.
function get_server_pid() {
  pgrep -af ProjectZomboid64 | grep "servername ${SERVER_NAME}" | grep -o -e "^[0-9]*"
}

# is_server_running prints true if server is running, or false if is not.
function is_server_running() {
  [ -n "$(get_screen_pid)" ] && echo "true" || echo "false"
}

# is_admin_exists prints true if admin username exists in PZ database.
function is_admin_exists() {
  [ "$(sqlite3 "${ZOMBOID_FILE_DB}" "SELECT count(*) FROM whitelist WHERE username='admin'" 2> /dev/null)" == "1" ] && echo "true" || echo "false"
}

# print_variables prints pzlsm variables.
function print_variables() {
  echo "${INFO} MEMORY_AVAILABLE:            ${MEMORY_AVAILABLE}"
  echo "${INFO} MEMORY_USED:                 ${MEMORY_USED}"
  echo "${INFO} CPU_CORE_COUNT:              ${CPU_CORE_COUNT}"
  echo "${INFO} APP_ID:                      ${APP_ID}"
  echo "${INFO} APP_DEDICATED_ID:            ${APP_DEDICATED_ID}"
  echo "${INFO} SCREEN_ZOMBOID:              ${SCREEN_ZOMBOID}"
  echo "${INFO} NOW:                         ${NOW}"
  echo "${INFO} TIMESTAMP:                   ${TIMESTAMP}"
  echo "${INFO} BASEDIR:                     ${BASEDIR}"
  echo "${INFO}"
  echo "${INFO} FILE_PZLSM_LOG:              ${FILE_PZLSM_LOG}"
  echo "${INFO} FILE_PZLSM_CONFIG:           ${FILE_PZLSM_CONFIG}"
  echo "${INFO} UTIL_RANGE_FILE:             ${UTIL_RANGE_FILE}"
  echo "${INFO} UTIL_RCON_FILE:              ${UTIL_RCON_FILE}"
  echo "${INFO}"
  echo "${INFO} SERVER_DIR:                  ${SERVER_DIR}"
  echo "${INFO} ZOMBOID_DIR:                 ${ZOMBOID_DIR}"
  echo "${INFO} ZOMBOID_DIR_SAVES:           ${ZOMBOID_DIR_SAVES}"
  echo "${INFO} ZOMBOID_DIR_LOGS:            ${ZOMBOID_DIR_LOGS}"
  echo "${INFO} ZOMBOID_DIR_SERVER:          ${ZOMBOID_DIR_SERVER}"
  echo "${INFO} ZOMBOID_DIR_DB:              ${ZOMBOID_DIR_DB}"
  echo "${INFO} ZOMBOID_DIR_MAP:             ${ZOMBOID_DIR_MAP}"
  echo "${INFO}"
  echo "${INFO} ZOMBOID_FILE_CONFIG_INI:     ${ZOMBOID_FILE_CONFIG_INI}"
  echo "${INFO} ZOMBOID_FILE_CONFIG_SANDBOX: ${ZOMBOID_FILE_CONFIG_SANDBOX}"
  echo "${INFO} ZOMBOID_FILE_DB:             ${ZOMBOID_FILE_DB}"
}

# save_config_example saves pzlsm config example.
function save_config_example() {
  bash -c "cat <<'EOF' > ${DIR_CONFIG}/pzlsm.example.cfg
#!/usr/bin/env bash

# SERVER_MEMORY_LIMIT contains memory Limit for JVM in MB.
SERVER_MEMORY_LIMIT=${SERVER_MEMORY_LIMIT}

# SERVER_NAME contains name of Project Zomboid server.
SERVER_NAME=\"${SERVER_NAME}\"

# CLEAR_MAP_DAY contains the number of days after which map chunks will
# be deleted if no one has visited them. Set to 0 to turn off.
CLEAR_MAP_DAY=${CLEAR_MAP_DAY}

# CLEAR_LOGS_DAY contains the number of days after which old game logs will
# be deleted. Set to 0 to turn off.
CLEAR_LOGS_DAY=${CLEAR_LOGS_DAY}

# CLEAR_STACK_TRACE_DAY contains the number of days after which old game
# hs_err_pid (java stack traces) files will be deleted. Set to 0 to turn off.
CLEAR_STACK_TRACE_DAY=${CLEAR_STACK_TRACE_DAY}

# CLEAR_BACKUPS_DAY contains the number of days after which old backups
# will be deleted. Set to 0 to turn off.
CLEAR_BACKUPS_DAY=${CLEAR_BACKUPS_DAY}

# CLEAR_TIME_MACHINE_DAY contains the number of days after which old
# time machine backups will be deleted. Set to 0 to turn off.
CLEAR_TIME_MACHINE_DAY=${CLEAR_TIME_MACHINE_DAY}

# BACKUP_ON_STOP contains switcher to make backup on every server stop.
BACKUP_ON_STOP=\"${BACKUP_ON_STOP}\"

# FIRST_RUN_ADMIN_PASSWORD contains password for user admin which be created
# on first server run.
FIRST_RUN_ADMIN_PASSWORD=\"${FIRST_RUN_ADMIN_PASSWORD}\"

# AUTO_RESTORE contains switcher to restart server if it was down.
AUTO_RESTORE=\"${AUTO_RESTORE}\"

# GITHUB_CONFIG_REPO contains link to github repo with pz config files.
# Leave it blank if you don't plan to use this.
GITHUB_CONFIG_REPO=\"${GITHUB_CONFIG_REPO}\"

# GITHUB_ACCESS_TOKEN contains access token for download server configs from GitHub.
# Leave it blank if you don't plan to use this.
GITHUB_ACCESS_TOKEN=\"${GITHUB_ACCESS_TOKEN}\"

DIR_PLUGINS=\"${DIR_PLUGINS}\"
EOF"
}

# print_version prints versions.
# TODO: Check installations.
function print_version() {
  echo "${INFO} Project Zomboid build ${PZ_VERSION}"
  echo "${INFO} pzlsm version ${VERSION}"
  echo "${INFO} gorcon version ${UTIL_RCON_VERSION}"
  echo "${INFO} range version ${UTIL_RANGE_VERSION}"
}

# strclear removes all spaces, quotation marks and tabs from a string.
function strclear() {
  local str=${1//\"/}; str=${str// /}; str=${str//$'\t'/}
  echo "${str}"
}

# install_dependencies installs the necessary dependencies to the server.
# You must have sudo privileges to call function install_dependencies.
# This is the only function in this script that needs root privileges.
# You can install dependencies yourself before running this script and do
# not call this function.
function install_dependencies() {
  sudo apt-get update

  # If a 64-bit version of the system is used, then 32-bit libraries must
  # be installed for SteamCMD.
  if [ "$(arch)" == "x86_64" ]; then
    sudo apt-get install -y lib32gcc-s1
  fi

  # Update the C libraries for system calls.
  sudo apt-get install -y libc6 libc6-dev libc6-dbg linux-libc-dev gcc

  # Install Java-SDK. It is required to run the Project Zomboid game server.
  sudo apt-get install -y openjdk-17-jdk

  # Install screen to run Project Zomboid in the background.
  sudo apt-get install -y screen

  # To access the game database, you will need the sqlite3 library.
  sudo apt-get install -y sqlite3

  # Install basic calculator.
  sudo apt-get install -y bc

  # Install jq for json config parsing.
  sudo apt-get install -y jq

  sudo apt-get install -y net-tools nmap

  echo "${OK} dependencies installed"
}

# create_folders creates folders for pzlsm script.
function create_folders() {
  mkdir -p "${DIR_BACKUPS}"
  mkdir -p "${DIR_LOGS}"
  mkdir -p "${DIR_CONFIG}"
  mkdir -p "${DIR_PUBLIC}"
  mkdir -p "${DIR_UTILS}"
  mkdir -p "${DIR_PLUGINS}"
  mkdir -p "${DIR_STATE}"

  # Config.
  save_config_example

  # Backups.
  mkdir -p "${DIR_BACKUPS_DOWN}"
  mkdir -p "${DIR_BACKUPS_ZOMBOID}"
  mkdir -p "${DIR_BACKUPS_COPY}"
  mkdir -p "${DIR_BACKUPS_PLAYERS}"
  mkdir -p "${DIR_BACKUPS_TIME_MACHINE}"

  # Logs
  mkdir -p "${DIR_LOGS}/gc"

  # Public.
  mkdir -p "${DIR_PUBLIC}/saves"
  mkdir -p "${DIR_PUBLIC}/logs"

  rm -f "${DIR_PUBLIC}/backups"
  rm -f "${DIR_PUBLIC}/logs/server"
  rm -f "${DIR_PUBLIC}/logs/gc"

  ln -s "${DIR_BACKUPS}" "${DIR_PUBLIC}/backups"
  ln -s "${ZOMBOID_DIR_LOGS}" "${DIR_PUBLIC}/logs/server"
  ln -s "${DIR_LOGS}/gc" "${DIR_PUBLIC}/logs/gc"

  ln -sf "${ZOMBOID_DIR_MAP}/WorldDictionary.bin" "${DIR_PUBLIC}/saves/WorldDictionary.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/WorldDictionaryLog.lua" "${DIR_PUBLIC}/saves/WorldDictionaryLog.lua"
  ln -sf "${ZOMBOID_DIR_MAP}/WorldDictionaryReadable.lua" "${DIR_PUBLIC}/saves/WorldDictionaryReadable.lua"
  ln -sf "${ZOMBOID_DIR_MAP}/erosion.ini" "${DIR_PUBLIC}/saves/erosion.ini"
  ln -sf "${ZOMBOID_DIR_MAP}/global_mod_data.bin" "${DIR_PUBLIC}/saves/global_mod_data.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_campfire.bin" "${DIR_PUBLIC}/saves/gos_campfire.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_farming.bin" "${DIR_PUBLIC}/saves/gos_farming.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_metaldrum.bin" "${DIR_PUBLIC}/saves/gos_metaldrum.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_rainbarrel.bin" "${DIR_PUBLIC}/saves/gos_rainbarrel.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/gos_trap.bin" "${DIR_PUBLIC}/saves/gos_trap.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/map_meta.bin" "${DIR_PUBLIC}/saves/map_meta.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/map_t.bin" "${DIR_PUBLIC}/saves/map_t.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/map_zone.bin" "${DIR_PUBLIC}/saves/map_zone.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/players.db" "${DIR_PUBLIC}/saves/players.db"
  ln -sf "${ZOMBOID_DIR_MAP}/reanimated.bin" "${DIR_PUBLIC}/saves/reanimated.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/recorded_media.bin" "${DIR_PUBLIC}/saves/recorded_media.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/vehicles.db" "${DIR_PUBLIC}/saves/vehicles.db"
  ln -sf "${ZOMBOID_DIR_MAP}/z_outfits.bin" "${DIR_PUBLIC}/saves/z_outfits.bin"
  ln -sf "${ZOMBOID_DIR_MAP}/zpop_virtual.bin" "${DIR_PUBLIC}/saves/zpop_virtual.bin"

  ln -sf "${ZOMBOID_FILE_DB}" "${DIR_PUBLIC}/saves/${SERVER_NAME}.db"

  echo "${OK} folders created"
}

# install_range_builder downloads the regex-range-builder script and puts it
# in the utils directory.
function install_range_builder() {
  test -d "${UTIL_RANGE_DIR}" && echo "${UTIL_RANGE_DIR}" && return

  wget -P "${DIR_UTILS}" "${UTIL_RANGE_LINK}"
  tar -zxvf "${DIR_UTILS}/v${UTIL_RANGE_VERSION}.tar.gz" -C "${DIR_UTILS}"
  rm "${DIR_UTILS}/v${UTIL_RANGE_VERSION}.tar.gz"
}

# install_rcon downloads the rcon client and puts it in the utils directory.
function install_rcon() {
  test -d "${UTIL_RCON_DIR}" && echo "${UTIL_RCON_DIR}" && return

  wget -P "${DIR_UTILS}" "${UTIL_RCON_LINK}"
  tar -zxvf "${DIR_UTILS}/rcon-${UTIL_RCON_VERSION}-amd64_linux.tar.gz" -C "${DIR_UTILS}"
  rm "${DIR_UTILS}/rcon-${UTIL_RCON_VERSION}-amd64_linux.tar.gz"
}

# is_updated checks the time of the last server update via steamcmd,
# compare it with the saved one, return a response about the need to
# restart if the time does not match and update the time in the repository
#
# TODO: Implement me.
# Check Project Zomboid update date in Steam.
# Check Project Zomboid mods update date in Steam.
function is_updated() {
  if [ ! -f "${ZOMBOID_MANIFEST}" ]; then
    echoerr "server manifest file not found"
    return 1
  fi

  # Get updated timestamp from manifest file.
  local updated=""
  updated=$(grep -oP "(?<=LastUpdated).*" "${ZOMBOID_MANIFEST}" | grep -o '[0-9]*')

  echo "false"
}

# install_server installs Project Zomboid dedicated server.
# As arguments, you can pass validate and beta parameters in any order.
# If validate, the integrity and relevance of the current files will be checked.
# The beta parameter will download and install the game from the experimental
# IWBUMS branch. Only the latest stable and IWBUMS branches are supported.
function install_server() {
  if [ "$(is_server_running)" == "true" ]; then
    echo "${ER} cannot install on started server"; return 0
  fi

  local beta="${STEAMCMD_BETA}"

  case $1 in
    none)
      beta="-beta none";;
    unstable)
      beta="-beta unstable";;
    iwbums)
      beta="-beta iwillbackupmysave -betapassword iaccepttheconsequences";;
    *)
      if [ -n "$1" ]; then
        beta="-beta $1"
      fi
  esac

  # Create a directory for steamcmd and go to it. If the directory
  # already exists, no errors occur.
  mkdir -p "${HOME}/steamcmd" && cd "${HOME}/steamcmd" || return

  # Download steamcmd if it is not in the specified directory.
  if [ ! -f "steamcmd.sh" ]; then
    wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz && tar -xvzf steamcmd_linux.tar.gz
    rm steamcmd_linux.tar.gz
  fi

  # Install Project Zomboid Server.
  ./steamcmd.sh +login "${STEAMCMD_USERNAME}" +force_install_dir "${SERVER_DIR}" +app_update ${APP_DEDICATED_ID} ${beta} validate +exit

  # Return to the script directory.
  cd "${BASEDIR}" || return

  echo "${OK} server installed"
}

# update_server updates Project Zomboid dedicated server.
function update_server() {
  if [ "$(is_server_running)" == "true" ]; then
    echo "${ER} cannot update on started server"; return 0
  fi

  cd "${HOME}/steamcmd" || return

  # Update Project Zomboid Server.
  ./steamcmd.sh +login "${STEAMCMD_USERNAME}" +force_install_dir "${SERVER_DIR}" +app_update ${APP_DEDICATED_ID} validate +exit

  # Return to the script directory.
  cd "${BASEDIR}" || return

  echo "${OK} server updated"
}

# fix_options changes game language to EN.
function fix_options() {
  sed -i -r "s/language=.*/language=EN/g" "${ZOMBOID_DIR}/options.ini"

  echo "${OK} options fixed"
}

# fix_args sets the home directory for the game, utf8 encoding, server name,
# game language, changes GC option.
function fix_args() {
  local arg_home=""
  arg_home=$(grep "Duser.home" "${SERVER_DIR}/ProjectZomboid64.json")
  [ "${arg_home}" ] && return 0

  # Set memory limit for JVM.
  sed -i -r "s/Xmx8g/Xmx${SERVER_MEMORY_LIMIT}m/g" "${SERVER_DIR}/ProjectZomboid64.json"

  # Change GC type.
  sed -i -r "s/UseZGC/UseG1GC/g" "${SERVER_DIR}/ProjectZomboid64.json"

  local set_home='"-Duser.home=.\/"'
  local set_encoding='"-Dfile.encoding=UTF-8"'
  local set_servername="\"-Dservername=${SERVER_NAME}\""
  local set_serverlang="\"-Duser.language=${SERVER_LANG}\""
  local set_gclog="\"-Xlog:gc*,gc+heap=debug,age*=debug:file=${DIR_LOGS}/gc/gc.out:time,uptime,level,tags:filesize=0:filecount=0\""

  local indent="\r\n\t\t"
  local _search='"-Dzomboid.steam=1",'
  local _replace="${_search}${indent}${set_home},${indent}${set_encoding},${indent}${set_servername},${indent}${set_serverlang},${indent}${set_gclog},"

  sed -i -r "s|${_search}|${_replace}|g" "${SERVER_DIR}/ProjectZomboid64.json"

  echo "${OK} args fixed"
}

# start starts the server in a screen window.
# An error message will be displayed if server has been started earlier.
function start() {
  echo "${INFO} starting the server..."

  local no_screen="$1"

  if [ "$(is_server_running)" == "true" ]; then
    echo "${INFO} server already started"; return 0
  fi

  rm -f "${DIR_STATE}/started"

  screen -wipe > /dev/null 2>&1; sleep 1s

  if [ "$no_screen" == "true" ]; then
    if ! "${SERVER_DIR}/start-server.sh" -servername "${SERVER_NAME}"; then
      echoerr "server is not started"; return 1
    fi
  else
    if ! env LANG=ru_RU.utf8 screen -U -mdS "${SCREEN_ZOMBOID}" "${SERVER_DIR}/start-server.sh" -servername "${SERVER_NAME}"; then
      echoerr "server is not started"; return 1
    fi
  fi

  if [ "$(is_admin_exists)" == "false" ] && [ -n "${FIRST_RUN_ADMIN_PASSWORD}" ]; then
    sleep 1s && screencmd "${FIRST_RUN_ADMIN_PASSWORD}"
    sleep 1s && screencmd "${FIRST_RUN_ADMIN_PASSWORD}"
  fi

  mkdir -p "${DIR_STATE}" && echo "${NOW}" > "${DIR_STATE}/started"
}

# stop stops the server.
function stop() {
  echo "${INFO} stopping the server..."

  rm -f "${DIR_STATE}/started"

  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server already stopped"; return 0
  fi

  # kickusers is used for fix a game bug.
  # When `quit` game command is executed, there is no log record the fact
  # that the players was exit the game. If you make a forced kick from the
  # server, then the log entry appears correctly.
  kickusers

  sleep 1s

  if ! screencmd 'quit'; then
    echoerr "server is not stopped correctly"
  fi

  # If after a regular shutdown server remains running, we must forcibly stop it.
  sleep 20s

  local pid_screen
  pid_screen=$(get_screen_pid)
  if [ -n "${pid_screen}" ]; then
    echo "${INFO} kill screen process ${pid_screen}"
    kill "${pid_screen}" > /dev/null 2>&1; sleep 1s
  fi

  echo "${OK} server is stopped"

  if [ "$1" == "fix" ] || [ "$2" == "fix" ]; then
    delete_mods_manifest
  fi

  if [ "$1" == "now" ] || [ "$1" == "kill" ] || [ "${BACKUP_ON_STOP}" != "true" ]; then
    return 0
  fi

  # After a stopping the server invokes the function of cleaning garbage that
  # the game generates during its operation.
  delete_old_chunks "${CLEAR_MAP_DAY}"
  delete_old_logs "${CLEAR_LOGS_DAY}"
  delete_old_java_stack_traces "${CLEAR_STACK_TRACE_DAY}"

  # Backups
  backup "world"
}

# restart stops the server and starts it after 10 seconds.
function restart() {
  echo "${INFO} restarting the server..."

  stop "$1" "$2"
  sleep 10s
  start
}

# autorestart restarts server if it stuck.
function autorestart() {
  if [ "${AUTO_RESTORE}" != "true" ]; then
    return 0
  fi

  local pid_zomboid=""
  pid_zomboid=$(get_server_pid)
  if [ -z "${pid_zomboid}" ] && [ -f "${DIR_STATE}/started" ]; then
    NOW=$(date "+%Y%m%d_%H%M%S")

    local down="${DIR_BACKUPS_DOWN}/${NOW}"
    mkdir "${down}"

    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -name \*.txt -exec cp {} "${down}" \;
    cp "${ZOMBOID_DIR}/server-console.txt" "${down}"
    cp "${DIR_LOGS}/gc/gc.out" "${down}"

    start

    return 0
  fi

  local result
  result=$(rconcmd players 5s 2>&1 >/dev/null | grep ': i/o timeout')
  if [ -n "${result}" ]; then
    NOW=$(date "+%Y%m%d_%H%M%S")

    local down="${DIR_BACKUPS_DOWN}/${NOW}"
    mkdir "${down}"

    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -name \*.txt -exec cp {} "${down}" \;
    cp "${ZOMBOID_DIR}/server-console.txt" "${down}"
    cp "${DIR_LOGS}/gc/gc.out" "${down}"

    restart kill
  fi
}

# shutdown_wrapper triggers informational messages for players to alert them of
# impending server shutdown. After 5 minutes, it calls the stop or restart
# function.
function shutdown_wrapper() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server already stopped"
    return 0
  fi

  ticker() {
    local msg=$1

    if [ "$2" != "now" ] && [ "$2" != "kill" ]; then
      echo "${INFO} ${msg} 5 minutes"
      screencmd "servermsg \"${msg} 5 minutes\""

      sleep 240s

      echo "${INFO} ${msg} 1 minute";
      screencmd "servermsg \"${msg} 1 minute\""

      sleep 50s
    fi

    if [ "$2" != "kill" ]; then
      echo "${INFO} ${msg} 10 seconds";
      screencmd "servermsg \"${msg} 10 seconds\""

      sleep 5s
      t=5
      while [ ${t} -gt 0 ]; do
        screencmd "servermsg \"${msg} ${t} seconds\""
        sleep 1s
        ((t=t-1))
      done
    fi
  }

  case "$1" in
    stop)
      ticker "Stopping the server in" "$2"
      stop "$2" "$3"
      ;;
    restart)
      ticker "Restarting the server in" "$2"
      restart "$2" "$3"
      ;;
    *)
      echoerr "wrong shutdown command: $1"
      return 1
      ;;
  esac
}

# console connects to screen session.
function console() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server is not running"; return 0
  fi

  screen -r "${SERVER_NAME}"
}

# screencmd calls the $1 command to the game using screen util.
# The screencmd function is faster than rconcmd, but you cannot get a response
# to the request. Therefore, it should be used when the answer is not needed.
function screencmd() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server is not running"; return 0
  fi

  local command="$1"
  [ -z "${command}" ] && { echoerr "command is not set"; return 1; }

  screen -S "${SCREEN_ZOMBOID}" -X stuff "${command}\r"
}

# rconcmd calls the $1 command to the game using Source RCON Protocol.
# The port and authorization parameters takes from the Project Zomboid config.
function rconcmd() {
  if [ "$(is_server_running)" == "false" ]; then
    echoerr "server is not running"; return 0
  fi

  local command="$1"
  [ -z "${command}" ] && { echoerr "command is not set"; return 1; }

  local timeout="$2"
  [ -z "${timeout}" ] && timeout=3s

  local host='127.0.0.1'
  local port=""
  local password=""

  port=$(grep "RCONPort=" "${ZOMBOID_FILE_CONFIG_INI}"); port=${port//RCONPort=/}; port=${port// /}
  password=$(grep "RCONPassword=" "${ZOMBOID_FILE_CONFIG_INI}"); password=${password//RCONPassword=/}; password=${password// /}

  ${UTIL_RCON_FILE} -a "${host}:${port}" -p "${password}" -T "${timeout}" "${command}"
}

# kickusers kicks all players from the server.
function kickusers() {
  local players=""
  if ! players=$(rconcmd "players"); then
    echoerr "kickusers: cannot get users"; return 0;
  fi

  local i=0

  players=$(echo "${players}" | grep ^"-")
  if [ "${players}" ]; then
    IFS=$'\n'

    declare -a a
    a=("${players}")

    for line in "${a[@]}"; do
      ((i=i+1))
      local username="${line:1}"
      screencmd "kickuser \"${username}\""
    done
  fi

  echo "${OK} kicked ${i} users"
}

# delete_mods_manifest deletes appworkshop_108600.acf file. It need to
# update mods correctly.
function delete_mods_manifest() {
  [ ! -f "${ZOMBOID_MODS_MANIFEST}" ] && return 0

  echo "${INFO} remove appworkshop_${APP_ID}.acf"
  rm "${ZOMBOID_MODS_MANIFEST}"
}

# delete_old_java_stack_traces deletes hs_err_pid*.log files that are older
# than $1 days from server root directory.
# If you do not pass the number of days $1, or pass the value 0 then the
# default value will be taken from the variable CLEAR_STACK_TRACE_DAY.
function delete_old_java_stack_traces() {
  local days="$1"
  [ -z "${days}" ] && days=${CLEAR_STACK_TRACE_DAY}

  # Do nothing if turned off in the settings.
  [ "${days}" -eq "0" ] && return

  # Remove java stack traces.
  local count
  (( days-- ))
  count=$(find "${SERVER_DIR}" -name "hs_err_pid*.log" -mtime +${days} | wc -l)
  find "${SERVER_DIR}" -name "hs_err_pid*.log" -mtime +${days} -delete
  (( days++ ))
  echo "${INFO} remove hs_err_pid*.log files older than ${days} days... ${count} files"
}

# delete_old_logs deletes log files that are older than $1 days from
# Zomboid/Logs directory.
# If you do not pass the number of days $1, or pass the value 0 then the
# default value will be taken from the variable CLEAR_LOGS_DAY.
function delete_old_logs() {
  local days="$1"
  [ -z "${days}" ] && days=${CLEAR_LOGS_DAY}

  # Do nothing if turned off in the settings.
  [ "${days}" -eq "0" ] && return 0

  # Remove old logs folders.
  local count
  (( days-- ))
  count=$(find "${ZOMBOID_DIR_LOGS}" -name "*.txt" -mtime +${days} | wc -l)
  find "${ZOMBOID_DIR_LOGS}" -name "*.txt" -mtime +${days} -delete
  (( days++ ))
  echo "${INFO} remove logs files older than ${days} days... ${count} files"

  # Remove empty logs folders.
  find "${ZOMBOID_DIR_LOGS}" -empty -type d -delete
}

# delete_zombies deletes all zpop_*_*.bin files from Zomboid/Saves directory.
# These files are responsible for placing zombies on the world.
# It is recommended to use with a turned off server. When used on a running
# server, it can create more problems than it solves.
# But it can help the game restart the threads responsible for the zombies,
# if they freeze.
function delete_zombies() {
  local count
  count=$(find "${ZOMBOID_DIR_MAP}" -name "zpop_*_*.bin" | wc -l)
  echo "${INFO} remove zpop_*_*.bin files... ${count} files"
  rm -rf "${ZOMBOID_DIR_MAP}/zpop_*_*.bin"
}

# delete_old_chunks deletes files map_*_*.bin older than $1 days from
# Zomboid/Saves directory.
# If you do not pass the number of days $1, or pass the value 0 then the
# default value will be taken from the variable CLEAR_MAP_DAY.
function delete_old_chunks() {
  local days="$1"
  [ -z "${days}" ] && days=${CLEAR_MAP_DAY}

  # Do nothing if turned off in the settings.
  [ "${days}" -eq "0" ] && return 0

  local count
  (( days-- ))
  count=$(find "${ZOMBOID_DIR_MAP}" -name "map_*_*.bin" -mtime +${days} | wc -l)
  find "${ZOMBOID_DIR_MAP}" -name "map_*_*.bin" -mtime +${days} -delete
  (( days++ ))
  echo "${INFO} remove chunks older than ${days} days... ${count} chunks"
}

# get_rectangle takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them.
function get_rectangle() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"
     echo "0 0 0 0"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"
     echo "0 0 0 0"; return 1
  fi

  local regexp='^[0-9]+$'

  # Upper right corner.
  IFS='x' read -ra point_top <<< "${from}"
  local top_x="${point_top[0]}"
  local top_y="${point_top[1]}"
  if ! [[ ${top_x} =~ $regexp ]] || ! [[ ${top_y} =~ $regexp ]]; then
     echoerr "upper right corner is invalid"
     echo "0 0 0 0"; return 1
  fi

  # Lower left corner.
  IFS='x' read -ra point_bot <<< "${to}"
  local bot_x="${point_bot[0]}";
  local bot_y="${point_bot[1]}"
  if ! [[ ${bot_x} =~ $regexp ]] || ! [[ ${bot_y} =~ $regexp ]]; then
     echoerr "lower left corner is invalid"
     echo "0 0 0 0"; return 1
  fi

  echo "${top_x} ${top_y} ${bot_x} ${bot_y}"
}

# map_regen takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them and deletes them.
#
# Example: map_regen 10626x10600 10679x10661
function map_regen() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))

  # Delete last digit to convert to chunk name.
  local top_x; top_x=$(echo "${rectangle[0]}/10" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}/10" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}/10" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}/10" |bc)

  if [ "${top_x}" -ge "${bot_x}" ] || [ "${top_y}" -ge "${bot_y}" ]; then
     echoerr "invalid points"
     return 1
  fi

  local count=0
  local count_success=0
  for (( x=top_x; x <= bot_x; x++ )) do
    for (( y=top_y; y <= bot_y; y++ )) do
      (( count++ ))
      local name="map_${x}_${y}.bin"
      rm "${ZOMBOID_DIR_MAP}/${name}" > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        (( count_success++ ))
      fi
    done
  done

  echo "${OK} deleted ${count_success} from ${count} chunks"
}

# map_copy takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them and copies them to
# backups/copy directory. With an additional argument, you can specify a name
# for the catalog of copied chunks. If you don't specify a name, then it will
# generated based on the coordinates.
#
# Example: map_copy 11586x8230 11639x8321
# Example: map_copy 11586x8230 11639x8321 bar
function map_copy() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))

  # Delete last digit to convert to chunk name.
  local top_x; top_x=$(echo "${rectangle[0]}/10" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}/10" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}/10" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}/10" |bc)

  if [ "${top_x}" -ge "${bot_x}" ] || [ "${top_y}" -ge "${bot_y}" ]; then
     echoerr "invalid points"
     return 1
  fi

  local copy_path="${DIR_BACKUPS_COPY}"
  if [ -z "$3" ]; then
    copy_path=${copy_path}/${NOW}_${from}_${to}
  else
    copy_path=${copy_path}/${NOW}_$3
  fi

  mkdir -p "${copy_path}" #> /dev/null 2>&1
  if [ ! $? -eq 0 ]; then
    echoerr "can not create directory ${copy_path} to copy"
    return 1
  fi

  local count=0
  local count_success=0
  for (( x=top_x; x <= bot_x; x++ )) do
    for (( y=top_y; y <= bot_y; y++ )) do
      (( count++ ))
      local name="map_${x}_${y}.bin"
      cp "${ZOMBOID_DIR_MAP}/${name}" "${copy_path}" > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        (( count_success++ ))
      else
        echoerr "can not copy chunk ${name}"
      fi
    done
  done

  echo "${OK} copied ${count_success} from ${count} chunks"
}

# map_copyto takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them and copies them to
# backups/copy directory and rename to new coordinates. With an additional
# argument, you can specify a name for the catalog of copied chunks. If you
# don't specify a name, then it will generated based on the coordinates.
#
# Example: map_copyto 9240x4800 9299x4859 11530x8200
# Example: map_copyto 9240x4800 9299x4859 11530x8200 maze
function map_copyto() {
  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))

  # Delete last digit to convert to chunk name.
  local top_x; top_x=$(echo "${rectangle[0]}/10" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}/10" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}/10" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}/10" |bc)

  if [ "${top_x}" -ge "${bot_x}" ] || [ "${top_y}" -ge "${bot_y}" ]; then
     echoerr "invalid points"
     return 1
  fi

  local from_new="$3"
  local regexp='^[0-9]+$'

  IFS='x' read -ra point_top <<< "${from_new}"
  local top_x_new; top_x_new=$(echo "${point_top[0]}/10" |bc)
  local top_y_new; top_y_new=$(echo "${point_top[1]}/10" |bc)

  if ! [[ ${top_x_new} =~ $regexp ]] || ! [[ ${top_y_new} =~ $regexp ]]; then
     echoerr "upper new point is invalid"
     return 1
  fi

  local copy_path="${DIR_BACKUPS_COPY}"
  if [[ -z "$4" ]]; then
    copy_path="${copy_path}/${NOW}_${from_new}"
  else
    copy_path="${copy_path}/${NOW}_$4"
  fi

  mkdir -p "${copy_path}" #> /dev/null 2>&1
  if [[ ! $? -eq 0 ]]; then
    echoerr "can not create directory ${copy_path} to copy"
    return 1
  fi

  local x_new="${top_x_new}"

  local count=0
  local count_success=0
  for (( x=top_x; x <= bot_x; x++ )) do
    local y_new="${top_y_new}"

    for (( y=top_y; y <= bot_y; y++ )) do
      (( count++ ))

      local name="map_${x}_${y}.bin"
      local name_new="map_${x_new}_${y_new}.bin"

      cp "${ZOMBOID_DIR_MAP}/${name}" "${copy_path}/${name_new}" > /dev/null 2>&1
      if [[ $? -eq 0 ]]; then
        (( count_success++ ))
      else
        echoerr "can not copy chunk ${name}"
      fi

      (( y_new++ ))
    done

    (( x_new++ ))
  done

  echo "${OK} copied ${count_success} from ${count} chunks"
}

# range takes the coordinates of the upper right and lower left points
# and builds a rectangular area of chunks from them for generating regexp rule
# for searching the log.
#
# Example range 4251x5869 4270x5884
# > (425[1-9]|426[0-9]|4270),(5869|587[0-9]|588[0-4])
function range() {
  if [ ! -f "${UTIL_RANGE_FILE}" ]; then
     echoerr "util range.sh is not found"; return 1
  fi

  local from="$1"
  if [ -z "${from}" ]; then
     echoerr "upper right corner is not set"; return 1
  fi

  local to="$2"
  if [ -z "${to}" ]; then
     echoerr "lower left corner is not set"; return 1
  fi

  local rectangle=($(get_rectangle "${from}" "${to}"))

  local top_x; top_x=$(echo "${rectangle[0]}" |bc)
  local top_y; top_y=$(echo "${rectangle[1]}" |bc)
  local bot_x; bot_x=$(echo "${rectangle[2]}" |bc)
  local bot_y; bot_y=$(echo "${rectangle[3]}" |bc)

  if [ "${top_x}" -ge "${bot_x}" ] || [ "${top_y}" -ge "${bot_y}" ]; then
     echoerr "invalid points"; return 1
  fi

  local range_x; range_x=$(${UTIL_RANGE_FILE} "${top_x}" "${bot_x}")
  local range_y; range_y=$(${UTIL_RANGE_FILE} "${top_y}" "${bot_y}")

  echo "${range_x},${range_y}"
}

# backup copies server files to backup directory.
# After successful copying, check for old backups and delete them.
function backup() {
  NOW=$(date "+%Y%m%d_%H%M%S")
  local type="$1"

  if [ "${type}" == "fast" ]; then
    time_machine_save "$NOW" && return 0 || return 1
  fi

  if [ "${type}" == "players" ]; then
    players_save "$NOW" && return 0 || return 1
  fi

  if [ "${type}" == "world" ]; then
    zomboid_save "$NOW" && return 0 || return 1
  fi

  echoerr "unknown backup \"${type}\" command"
}

# time_machine_save saves database files to backup folder.
function time_machine_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "fast world save on ${NOW} failed";
  }

  # delete_old_time_machines deletes files servername_date_time.tar.gz older
  # than $1 days from backups/timemachine directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_TIME_MACHINE_DAY.
  delete_old_time_machines() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_TIME_MACHINE_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_TIME_MACHINE}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_TIME_MACHINE}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove time machine backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} fast world saving on ${NOW}..."

  local machine_name="${SERVER_NAME}_${NOW}"
  local machine_path="${DIR_BACKUPS_TIME_MACHINE}/${machine_name}"

  if ! mkdir -p "${machine_path}"; then
    echoerr "fast world save on ${NOW} failed"; return 1
  fi

  echo "${INFO} backup players.db..."
  if ! cp "${ZOMBOID_DIR_MAP}/players.db" "${machine_path}/players.db"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup vehicles.db..."
  if ! cp "${ZOMBOID_DIR_MAP}/vehicles.db" "${machine_path}/vehicles.db"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup WorldDictionary.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/WorldDictionary.bin" "${machine_path}/WorldDictionary.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup map_meta.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/map_meta.bin" "${machine_path}/map_meta.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup map_t.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/map_t.bin" "${machine_path}/map_t.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup map_zone.bin..."
  if ! cp "${ZOMBOID_DIR_MAP}/map_zone.bin" "${machine_path}/map_zone.bin"; then
    echoerr_del "${machine_path}"; return 1
  fi

  echo "${INFO} backup ${SERVER_NAME}.db..."
  if ! cp "${ZOMBOID_FILE_DB}" "${machine_path}/${SERVER_NAME}.db"; then
    echoerr_del "${machine_path}"; return 1
  fi

  if ! tar -czf "${machine_path}.tar.gz" -C "${DIR_BACKUPS_TIME_MACHINE}" "${machine_name}"; then
    echoerr_del "${machine_path}"; return 1
  fi

  rm -rf "${machine_path}"

  echo "${OK} fast world save on ${NOW} completed"
  delete_old_time_machines "${CLEAR_TIME_MACHINE_DAY}"
}

# players_save saves players database file to backup folder.
function players_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "players database save on ${NOW} failed";
  }

  # delete_old_players deletes files players_*_*.db older than $1 days from
  # backups/players directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_TIME_MACHINE_DAY.
  delete_old_players() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_TIME_MACHINE_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_PLAYERS}" -name "players_*_*.db" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_PLAYERS}" -name "players_*_*.db" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove players backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} backup players.db..."

  local name="players_${NOW}.db"
  if ! cp "${ZOMBOID_DIR_MAP}/players.db" "${DIR_BACKUPS_PLAYERS}/${name}"; then
    echoerr_del "${DIR_BACKUPS_PLAYERS}/${name}"; return 1
  fi

  echo "${OK} backup ${name} created successful"
  delete_old_players "${CLEAR_TIME_MACHINE_DAY}"
}

# zomboid_save saves Zomboid folder file to backup folder.
function zomboid_save() {
  [ -z "$1" ] && NOW=$(date "+%Y%m%d_%H%M%S") || NOW="$1"

  echoerr_del() {
    rm -rf "$1";
    echoerr "world save on ${NOW} failed";
  }

  # delete_old_zomboid deletes files ${SERVER_NAME}_*_*.tar.gz older than
  # $1 days from backups/zomboid directory.
  # If you do not pass the number of days $1, or pass the value 0 then the
  # default value will be taken from the variable CLEAR_BACKUPS_DAY.
  delete_old_zomboid() {
    local days="$1"
    [ -z "${days}" ] && days=${CLEAR_BACKUPS_DAY}

    # Do nothing if turned off in the settings.
    [ "${days}" -eq "0" ] && return 0

    local count
    (( days-- ))
    count=$(find "${DIR_BACKUPS_ZOMBOID}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} | wc -l)
    find "${DIR_BACKUPS_ZOMBOID}" -name "${SERVER_NAME}_*_*.tar.gz" -mtime +${days} -delete
    (( days++ ))
    echo "${INFO} remove world backups older than ${days} days... ${count} backups"
  }

  echo "${INFO} world save on ${NOW}..."

  local name="${SERVER_NAME}_${NOW}.tar.gz"
  if ! tar -czf "${DIR_BACKUPS_ZOMBOID}/${name}" --warning=no-file-changed -C "${ZOMBOID_DIR}" .; then
    echoerr_del "${DIR_BACKUPS_ZOMBOID}/${name}"; return 1
  fi

  echo "${OK} world save on ${NOW} completed"
  delete_old_zomboid "${CLEAR_BACKUPS_DAY}"
}

# log_search looks for string $1 in log files. Chat logs excluded from search.
# Using the optional parameter $2, you can specify the name of the log file to
# search.
#
# Example: log_search outdead
# Example: log_search outdead user
# Example: log_search outdead user connected
function log_search() {
  if [ -z "$1" ]; then
     echoerr "search param is not set"; return 1
  fi

  local filename="$2"
  if [ -z "${filename}" ]; then
    #grep --exclude=*_chat.txt -rIah -E "$1" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
    grep --exclude=*_chat.txt --exclude=*_DebugLog-server.txt -rIah -E "$1" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
    return 0
  fi

  local action="$3"
  if [ -z "${action}" ]; then
    grep --include=*_"${filename}".txt -rIah -E "$1" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
    return 0
  fi

  local limit="$4"
  if [ -n "${limit}" ]; then
    grep --include=*_"${filename}".txt -rIah -E "$1\"? ${action}" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3 | tail -n "${limit}"
  else
    grep --include=*_"${filename}".txt -rIah -E "$1\"? ${action}" "${ZOMBOID_DIR_LOGS}" | sort -b -k1.8,1.9 -k1.5,1.6 -k1.2,1.3
  fi
}

# clog_search looks for string $1 in current log files. Chat logs excluded
# from search. Using the optional parameter $2, you can specify the name of
# the log file to search.
#
# Example: log_search outdead
# Example: log_search outdead user
# Example: log_search outdead user connected
function clog_search() {
  if [ -z "$1" ]; then
     echoerr "search param is not set"; return 1
  fi

  local filename="$2"
  if [ -z "${filename}" ]; then
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -not -iname "*_DebugLog-server.txt" -not -iname "*_chat.txt" -exec grep -E "$1" {} \; | sort
    return 0
  fi

  local action="$3"
  if [ -z "${action}" ]; then
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -iname "*_${filename}.txt" -exec grep -E "$1" {} \; | sort
    return 0
  fi

  local limit="$4"
  if [ -n "${limit}" ]; then
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -iname "*_${filename}.txt" -exec grep -E "$1\"? ${action}" {} \; | tail -n "${limit}" | sort
  else
    find "${ZOMBOID_DIR_LOGS}" -maxdepth 1 -type f -iname "*_${filename}.txt" -exec grep -E "$1\"? ${action}" {} \; | sort
  fi
}

# fn_sqlite executes query 1 to the Project Zomboid database and displays result.
#
# Example: fn_sqlite 'select * from whitelist limit 1'
function fn_sqlite() {
  local query="$1"
  if [ -z "${query}" ]; then
     echoerr "query param is not set"; return 1
  fi

  sqlite3 "${ZOMBOID_FILE_DB}" "${query}"
}

# fn_vehicles prints vehicles coordinates.
function fn_vehicles() {
  sqlite3 -separator ',' "${ZOMBOID_FILE_VEHICLES_DB}" "SELECT cast(round(x) as int) as x, cast(round(y) as int) as y, 0 as z FROM vehicles;"
}

# restore_players replaces players.db database from backup.
function restore_players() {
  local filename="$1"
  if [ -z "${filename}" ]; then
     echoerr "filename param is not set"; return 1
  fi

  local path="${DIR_BACKUPS_PLAYERS}/${filename}"
  if [ ! -f "${path}" ]; then
    echoerr "players backup ${filename} does not exist"; return 1
  fi

  if [ "$(is_server_running)" == "true" ]; then
    echoerr "cannot be executed on a running server"; return 1
  fi

  if ! cp "${path}" "${ZOMBOID_DIR_MAP}/players.db"; then
    echoerr "players backup ${filename} was not restored"; return 1
  fi

  echo "${OK} players backup ${filename} restored successful"
}

PLUGINS_COMMANDS_HELP=""

IFS=';' read -ra ADDR <<< "${DIR_PLUGINS}"
for i in "${ADDR[@]}"; do
  for f in "${i}"/*.sh ; do
    test -f "${f}" && {
      if grep -E '^[[:space:]]*([[:alnum:]_]+[[:space:]]*\(\)|function[[:space:]]+[[:alnum:]_]+)' "${f}" | grep -w main > /dev/null; then
        echoerr "broken plugin $(basename "${f}")"; exit 1
      fi

      if grep -E '^[[:space:]]*([[:alnum:]_]+[[:space:]]*\(\)|function[[:space:]]+[[:alnum:]_]+)' "${f}" | grep -w load > /dev/null; then
        . "${f}";

        if [ -n "$CMD" ]; then
          IFS=' ' read -ra args <<< "${CMD}"
          load "${args[@]}"
        else
          load "$@"
        fi
      fi
    }
  done
done

function print_help() {
  echo "NAME:"
  echo "  pzlsm - Terminal tool for manage Project Zomboid server on Linux"
  echo ""
  echo "USAGE:"
  echo "  $0 [global options] command [arguments...] [options]"
  echo ""
  echo "VERSION:"
  echo "  ${VERSION}"
  echo
  echo "DESCRIPTION:"
  echo "  Tool kit for installation and management of Project Zomboid dedicated servers on Linux"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --variables, --vars     Print variables."
  echo "  --version               Print the version."
  echo "  --help                  Show help."
  echo
  echo "COMMANDS:"
  echo "  install [args]          Installs Project Zomboid dedicated server."
  echo "  update                  Updates Project Zomboid dedicated server."
  echo "  sync                    Downloads Project Zomboid config files from github repo (DEPRECATED)."
  echo "  start [args]            Starts the server in a screen window. An error message will"
  echo "                          be displayed if server has been started earlier."
  echo "  stop [args]             Stops the server. Triggers informational messages for players"
  echo "                          to alert them of impending server shutdown."
  echo "  restart [args]          Restarts the server. Triggers informational messages for players"
  echo "                          to alert them of impending server shutdown."
  echo "  autorestart             Restarts server if it stuck an backups last logs."
  echo "  cmd [args]              Executes the 1 argument as a command on the game server."
  echo "  kickusers               Kicks all players from the server."
  echo "  delfile [args]          Deletes selected Project Zomboid files."
  echo "  map_regen [args]        Takes the coordinates of the upper right and lower left points"
  echo "                          and builds a rectangular area of chunks from them and deletes them."
  echo "  map_copy [args]         Takes the coordinates of the upper right and lower left points"
  echo "                          and builds a rectangular area of chunks from them and copies them to"
  echo "                          backups/copy directory. With an additional argument, you can specify"
  echo "                          a name for the catalog of copied chunks. If you don't specify a name,"
  echo "                          then it will generated based on the coordinates"
  echo "  map_copyto [args]       Takes the coordinates of the upper right and lower left points"
  echo "                          and builds a rectangular area of chunks from them and copies them"
  echo "                          to backups/copy directory and rename to new coordinates. With an"
  echo "                          additional argument, you can specify a name for the catalog of copied"
  echo "                          chunks. If you don't specify a name, then it will generated based on"
  echo "                          the coordinates."
  echo "  range [args]            Takes the coordinates of the upper right and lower left points"
  echo "                          and builds a rectangular area of chunks from them for generating regexp"
  echo "                          rule for searching the log."
  echo "  backup [args]           Copies server files to backup directory. After successful copying, check"
  echo "                          for old backups and delete them."
  echo "  log [args]              Looks for string 1 in log files. Chat logs excluded from search."
  echo "                          Using the optional parameter 2, you can specify the name of the log"
  echo "                          file to search."
  echo "  сlog [args]             Looks for string 1 in current log files. Chat logs excluded from"
  echo "                          search. Using the optional parameter 2, you can specify the name of the"
  echo "                          log file to search."
  echo "  sql [args]              Executes query 1 to the Project Zomboid database and displays result."
  echo "  vehicles                Prints vehicles coordinates."
  echo "  restore_players [args]  Replaces players.db database from backup."
  echo
  echo "PLUGINS:"
  echo "  ${PLUGINS_COMMANDS_HELP}"
  echo
  echo "COPYRIGHT:"
  echo "  Copyright (c) ${YEAR} ${AUTHOR}"
}

function print_help_install() {
  echo "COMMAND NAME:"
  echo "  install"
  echo
  echo "DESCRIPTION:"
  echo "  Installs Project Zomboid dedicated server and necessary dependencies."
  echo "  Keep sub commands empty to install all is necessary."
  echo
  echo "USAGE:"
  echo "  $0 install command [arguments...] [options...]"
  echo
  echo "OPTIONS:"
  echo "  --branch|-b       Specifies branch name to install the game. Can take the"
  echo "                    following values: none, beta, unstable (Default = none)."
  echo "  --no-fixes|-n     Do not apply fixes after server installation."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 install"
  echo "  $0 install -b none"
  echo "  $0 install -b unstable -n"
  echo
  echo "COMMANDS:"
  echo "  dependencies      Installs necessary dependencies to the server."
  echo "  EXAMPLE:"
  echo "    $0 install dependencies"
  echo
  echo "  folders           Creates necessary folders for pzlsm script."
  echo "  EXAMPLE:"
  echo "    $0 install folders"
  echo
  echo "  utils             Installs additional utils to the server."
  echo "  EXAMPLE:"
  echo "    $0 install utils"
  echo
  echo "  prepare           Installs necessary dependencies, additional utils to"
  echo "                    the server and creates necessary folders for pzlsm script."
  echo "  EXAMPLE:"
  echo "    $0 install prepare"
  echo
  echo "  server            Installs only Project Zomboid dedicated server."
  echo "  OPTIONS:"
  echo "    --branch|-b     Specifies branch name to install the game. Can take the"
  echo "                    following values: none, beta, unstable (Default = none)."
  echo "    --no-fixes|-n   Do not apply fixes after server installation."
  echo "  EXAMPLE:"
  echo "    $0 install server -b unstable"
  echo "    $0 install server -b unstable -n"
  echo "    $0 install server -n"
  echo
  echo "  fix               Only apply fixes (Changes game language to EN and sets"
  echo "                    Project Zomboid args)."
  echo "  EXAMPLE:"
  echo "    $0 install fix"
}

function print_help_update() {
  echo "COMMAND NAME:"
  echo "  update"
  echo
  echo "DESCRIPTION:"
  echo "  Updates Project Zomboid dedicated server."
  echo
  echo "USAGE:"
  echo "  $0 update command [arguments...] [options...]"
  echo
  echo "OPTIONS:"
  echo "  --no-fixes|-n     Do not apply fixes after server installation."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 update"
  echo "  $0 update -n"
}

function print_help_start() {
  echo "COMMAND NAME:"
  echo "  start"
  echo
  echo "DESCRIPTION:"
  echo "  Starts Project Zomboid dedicated server."
  echo
  echo "USAGE:"
  echo "  $0 start command [arguments...] [options...]"
  echo
  echo "OPTIONS:"
  echo "  --no-screen|-n    Runs server without screen session."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 start"
  echo "  $0 start -n"
}

function print_help_stop() {
  echo "COMMAND NAME:"
  echo "  stop"
  echo
  echo "DESCRIPTION:"
  echo "  Stops Project Zomboid dedicated server in 5 minutes."
  echo "  You can change timer period with arguments \"now\" and \"kill\"."
  echo
  echo "USAGE:"
  echo "  $0 stop [arguments...] [options...]"
  echo
  echo "ARGUMENTS:"
  echo "  fix               Delete mods manifest file for force update mods. DEPRECATED, use --fixes option."
  echo "  now               Stops server in 10 seconds."
  echo "  kill              Stops the server immediately."
  echo
  echo "OPTIONS:"
  echo "  --fixes|-f        Delete mods manifest file for force update mods."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 stop"
  echo "  $0 stop -f"
  echo "  $0 stop now -f"
  echo "  $0 stop -f kill"
}

function print_help_restart() {
  echo "COMMAND NAME:"
  echo "  restart"
  echo
  echo "DESCRIPTION:"
  echo "  Restarts Project Zomboid dedicated server in 5 minutes."
  echo "  You can change timer period with arguments \"now\" and \"kill\"."
  echo
  echo "USAGE:"
  echo "  $0 restart [arguments...] [options...]"
  echo
  echo "ARGUMENTS:"
  echo "  fix               Delete mods manifest file for force update mods. DEPRECATED, use --fixes option."
  echo "  now               Restarts server in 10 seconds."
  echo "  kill              Restarts the server immediately."
  echo
  echo "OPTIONS:"
  echo "  --fixes|-f        Delete mods manifest file for force update mods."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 restart"
  echo "  $0 restart -f"
  echo "  $0 restart now -f"
  echo "  $0 restart -f kill"
}

function print_help_cmd() {
  echo "COMMAND NAME:"
  echo "  cmd"
  echo
  echo "DESCRIPTION:"
  echo "  Executes command on the game server. To see list of allowed commands"
  echo "  execute $0 cmd help."
  echo
  echo "USAGE:"
  echo "  $0 cmd command [options...]"
  echo
  echo "OPTIONS:"
  echo "  --rcon|-r         Use RCON protocol. Prints response in terminal. Used by default."
  echo "  --screen|-s       Sends command to screen session. No response. Faster then rcon, "
  echo "                    can work when rcon is not enabled."
  echo "  --help            Prints help."
  echo
  echo "EXAMPLE:"
  echo "  $0 cmd players"
  echo "  $0 cmd players -r"
  echo "  $0 cmd quit -s"
  echo "  $0 cmd \"banuser TestUser\""
  echo "  $0 cmd 'banuser \"Test User\"'"
}

function print_help_delfile() {
  echo "COMMAND NAME:"
  echo "  delfile"
  echo
  echo "DESCRIPTION:"
  echo "  Deletes selected Project Zomboid files."
  echo
  echo "USAGE:"
  echo "  $0 delfile [global options...] command"
  echo
  echo "GLOBAL OPTIONS:"
  echo "  --help            Prints help."
  echo
  echo "COMMANDS:"
  echo "  manifest          Deletes appworkshop_108600.acf file. It need to"
  echo "                    update mods correctly."
  echo "  EXAMPLE:"
  echo "    $0 delfile manifest"
  echo
  echo "  zombies           Deletes all zpop_*_*.bin files from Zomboid/Saves directory."
  echo "                    These files are responsible for placing zombies on the world."
  echo "                    It is recommended to use with a turned off server. When used on"
  echo "                    a running server, it can create more problems than it solves."
  echo "  EXAMPLE:"
  echo "    $0 delfile zombies"
}

# main contains a proxy for entering permissible functions.
function main() {
  case "$1" in
    install)
      if [ "$(is_server_running)" == "true" ]; then
        echo "${ER} cannot install on started server"; return 0
      fi

      local branch="none"
      local fixes="true"

      while [[ -n "$2" ]]; do
        case "$2" in
          --branch|-b) branch="$3" ;;
          --no-fixes|-n) fixes="false" ;;
          dependencies|dep)
            echo "${INFO} Installing dependencies.."

            install_dependencies
            return ;;
          folders)
            echo "${INFO} Creating required folders.."

            create_folders
            return ;;
          utils)
            echo "${INFO} Installing additional utils.."

            install_range_builder
            install_rcon
            return ;;
          prepare)
            echo "${INFO} Installing dependencies, additional utils and creating required folders.."

            install_dependencies
            create_folders
            install_range_builder
            install_rcon
            return ;;
          server)
            while [[ -n "$3" ]]; do
              case "$3" in
                --branch|-b) branch="$4" ;;
                --no-fixes|-n) fixes="false" ;;
              esac

              shift
            done

            echo "${INFO} Installing only Project Zomboid server from \"${branch}\" branch.."

            install_server "${branch}"
            if [ "${fixes}" == "true" ]; then
              fix_options
              fix_args
            fi
            return ;;
          --help)
            print_help_install
            return ;;
          fix)
            echo "${INFO} Apply fixes.."
            fix_options
            fix_args
            return ;;
        esac

        shift
      done

      echo "${INFO} Installing dependencies, additional utils, creating required folders and installs PZ server.."
      install_dependencies
      create_folders
      install_range_builder
      install_rcon
      install_server "${branch}"
      if [ "${fixes}" == "true" ]; then
        fix_options
        fix_args
      fi ;;
    update)
      if [ "$(is_server_running)" == "true" ]; then
        echo "${ER} cannot update on started server"; return 0
      fi

      local fixes="true"

      while [[ -n "$2" ]]; do
        case "$2" in
          --no-fixes|-n) fixes="false" ;;
          --help)
            print_help_update
            return ;;
        esac

        shift
      done

      echo "${INFO} Updating Project Zomboid server.."

      update_server

      if [ "${fixes}" == "true" ]; then
        fix_options
        fix_args
      fi ;;
    sync)
      # TODO: Deprecate me.
      config_pull;;
    start)
      local no_screen="false"

      while [[ -n "$2" ]]; do
        case "$2" in
          --no-screen|-n) no_screen="true";;
          --help)
            print_help_start
            return ;;
        esac

        shift
      done

      start "${no_screen}";;
    stop)
      local when
      local fixes

      while [[ -n "$2" ]]; do
        case "$2" in
          now|kill) when="$2";;
          --fixes|-f|fix) fixes="fix";;
          --help)
            print_help_stop
            return ;;
        esac

        shift
      done

      shutdown_wrapper "stop" "${when}" "${fixes}";;
    restart)
      local when
      local fixes

      while [[ -n "$2" ]]; do
        case "$2" in
          now|kill) when="$2";;
          --fixes|-f|fix) fixes="fix";;
          --help)
            print_help_restart
            return ;;
        esac

        shift
      done

      shutdown_wrapper "restart" "${when}" "${fixes}";;
    autorestart)
      autorestart;;
    console)
      console;;
    cmd)
      local proto="rcon"
      local command

      while [[ -n "$2" ]]; do
        case "$2" in
          --screen|-s) proto="screen" ;;
          --rcon|-r) proto="rcon" ;;
          --help)
            print_help_cmd
            return ;;
          *)
            if [ -n "${command}" ]; then
              echoerr "to many arguments"; return
            fi
            command="$2" ;;
        esac

        shift
      done

      if [ "${proto}" == "rcon" ]; then
         rconcmd "${command}"
      else
         screencmd "${command}"
      fi ;;
    kickusers)
      kickusers;;
    delfile)
      while [[ -n "$2" ]]; do
        case "$2" in
          manifest)
            delete_mods_manifest
            return ;;
          zombies)
            delete_zombies
            return ;;
          --help|*)
            print_help_delfile
            return ;;
        esac

        shift
      done

      print_help_delfile ;;
    map_regen)
      map_regen "$2" "$3";;
    map_copy)
      map_copy "$2" "$3" "$4";;
    map_copyto)
      map_copyto "$2" "$3" "$4" "$5";;
    range)
      local bottom="$3"
      if [ "${bottom}" == "-" ]; then
        bottom=$4
      fi

      range "$2" "${bottom}";;
    backup)
      backup "$2";;
    log)
      log_search "$2" "$3" "$4" "$5";;
    clog)
      clog_search "$2" "$3" "$4" "$5";;
    sql)
      fn_sqlite "$2";;
    vehicles)
      fn_vehicles;;
    restore_players)
      restore_players "$2";;
    --variables|--vars)
      print_variables;;
    --version)
      print_version;;
    --help)
      print_help;;
    --test)
      echo "test"
      is_admin_exists
  esac
}

if [ -z "$1" ]; then
  echo "${INFO} Permissible commands:"
  echo "........ --variables"
  echo "........ --version"
  echo "........ --help"
  echo "........ install command [arguments...] [options...]"
  echo "........ update"
  echo "........ start [options...]"
  echo "........ stop [options...]"
  echo "........ restart [options...]"
  echo "........ autorestart"
  echo "........ console"
  echo "........ cmd command"
  echo "........ kickusers"
  echo "........ delfile command"
  echo "........ map_regen {top} {bottom}"
  echo "........ map_copy {top} {bottom} {name}"
  echo "........ map_copyto {top} {bottom} {top_new} {bottom_new} {name}"
  echo "........ range {top} {bottom}"
  echo "........ backup {type}"
  echo "........ log {search} {type} {action} {limit}"
  echo "........ clog {search} {type} {action} {limit}"
  echo "........ sql {query}"
  echo "........ restore_players {filename}"
  echo "........ sync"
  printf "[  >>  ] " & read CMD
fi

if [ -n "$CMD" ]; then
  IFS=' ' read -ra args <<< "${CMD}"
  main "${args[@]}"
else
  main "$@"
fi
